

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/pages/CollagePage.js ===

import { useContext, useState, useEffect } from "react";
import { Helmet } from "react-helmet-async";
import { useTheme } from "@mui/material/styles";
import { useMediaQuery } from "@mui/material";
import { Dashboard } from "@mui/icons-material";

import { UserContext } from "../UserContext";
import { useSubscribeDialog } from "../contexts/useSubscribeDialog";

// Import configuration
import { aspectRatioPresets, layoutTemplates, getLayoutsForPanelCount } from "../components/collage/config/CollageConfig";

// Import components from steps
import CollageImagesStep from "../components/collage/steps/CollageImagesStep";
import CollageSettingsStep from "../components/collage/steps/CollageSettingsStep";
import UpgradeMessage from "../components/collage/components/UpgradeMessage";

// Import UI components
import { PageHeader } from "../components/collage/components/CollageUIComponents";
import { 
  MainContainer, 
  ContentPaper, 
  CollageLayout,
  CollageResult 
} from "../components/collage/components/CollageLayoutComponents";

// Import utilities for collage generation
import { 
  calculateCanvasDimensions, 
  getAspectRatioValue
} from "../components/collage/utils/CanvasLayoutRenderer";

// Import the new collage generation service
import { generateCollage } from "../components/collage/utils/CollageGenerator";

// Import the panel mapping utilities
import { sanitizePanelImageMapping } from "../components/collage/utils/PanelMappingUtils";

// Import state management custom hook
import { useCollageState } from "../components/collage/hooks/useCollageState";

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

// Helper debug logger function that only logs when DEBUG_MODE is true
const debugLog = (...args) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Helper for warnings that should still show in production
const debugWarn = (...args) => {
  if (DEBUG_MODE) {
    console.warn(...args);
  } else if (args[0] && args[0].includes('critical')) {
    // Allow critical warnings to show even in production
    console.warn(...args);
  }
};

// Helper for errors that should always show
const logError = (...args) => {
  console.error(...args);
};

// Collage page component - provides UI for creating collages
export default function CollagePage() {
  // Access theme for responsiveness and custom styling
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const isMediumScreen = useMediaQuery(theme.breakpoints.down('md'));
  
  // User authentication and subscription context
  const { user } = useContext(UserContext);
  const { openSubscriptionDialog } = useSubscribeDialog();
  
  // Determine if user is authorized to use the collage tool
  const authorized = (user?.userDetails?.magicSubscription === "true" || user?.['cognito:groups']?.includes('admins'));
  
  // Use our custom hook to manage collage state
  const {
    selectedImages,
    panelImageMapping,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    finalImage,
    setFinalImage,
    isCreatingCollage,
    setIsCreatingCollage,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    addImage,
    removeImage,
    updateImage,
    clearImages,
    updatePanelImageMapping,
  } = useCollageState();
  
  // Define border thickness options
  const borderThicknessOptions = [
    { label: "None", value: 0 },
    { label: "Thin", value: 6 },
    { label: "Medium", value: 16 },
    { label: "Thicc", value: 40 },
    { label: "Thiccer", value: 80 },
    { label: "XTRA THICC", value: 120 }
  ];

  // Get layouts compatible with the current panel count and aspect ratio
  const getCompatibleTemplates = () => {
    // Get all templates for the current panel count
    const panelTemplates = getLayoutsForPanelCount(panelCount);
    
    // Filter by aspect ratio compatibility
    const aspectRatioCategory = getAspectRatioPreset(selectedAspectRatio)?.category || 'any';
    
    const compatibleTemplates = panelTemplates.filter(template => {
      // Template is compatible if it has no aspect ratio constraint or matches the current one
      return !template.aspectRatioCategory || template.aspectRatioCategory === aspectRatioCategory || template.aspectRatioCategory === 'any';
    });
    
    // Sort by priority (lower number = higher priority)
    return compatibleTemplates.sort((a, b) => {
      if (a.priority !== undefined && b.priority !== undefined) {
        return a.priority - b.priority;
      }
      return 0;
    });
  };

  // Helper function to get the aspect ratio preset from its ID
  const getAspectRatioPreset = (id) => {
    return aspectRatioPresets.find(preset => preset.id === id);
  };

  // Select the most suitable template when panel count or aspect ratio changes
  useEffect(() => {
    const compatibleTemplates = getCompatibleTemplates();
    
    // If no template is selected or the current one isn't compatible, select the first one
    if (!selectedTemplate || 
        selectedTemplate.minImages > panelCount || 
        selectedTemplate.maxImages < panelCount) {
      
      if (compatibleTemplates.length > 0) {
        // Select the first (highest priority) compatible template
        setSelectedTemplate(compatibleTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  }, [panelCount, selectedAspectRatio, selectedTemplate]);

  // Submit the collage for creation
  const handleCreateCollage = async () => {
    setIsCreatingCollage(true);
    
    try {
      // Use the collage generator service
      debugLog(`[PAGE DEBUG] Creating collage with panelCount: ${panelCount}, borderThickness: ${borderThickness}, borderColor: ${borderColor}`);
      debugLog(`[PAGE DEBUG] borderThicknessOptions:`, borderThicknessOptions);
      
      const dataUrl = await generateCollage({
        selectedTemplate,
        selectedAspectRatio,
        panelCount,
        selectedImages,
        panelImageMapping,
        borderThickness,
        borderColor,
        borderThicknessOptions,
        theme
      });
      
      setFinalImage(dataUrl);
    } catch (error) {
      logError('Error generating collage:', error);
    } finally {
      setIsCreatingCollage(false);
    }
  };

  // Log changes to border color
  useEffect(() => {
    debugLog(`[PAGE DEBUG] Border color changed to: ${borderColor}`);
  }, [borderColor]);

  // Props for the settings step component
  const settingsStepProps = {
    selectedImages,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    handleNext: handleCreateCollage,
    aspectRatioPresets,
    layoutTemplates,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    borderThicknessOptions
  };
  
  // Props for the images step component
  const imagesStepProps = {
    selectedImages,
    addImage,
    removeImage,
    updateImage,
    clearImages,
    panelImageMapping,
    updatePanelImageMapping,
    panelCount,
    selectedTemplate,
    selectedAspectRatio,
    borderThickness,
    borderColor,
    borderThicknessOptions,
    handleNext: handleCreateCollage
  };

  // Log the panel mapping for debugging
  useEffect(() => {
    if (DEBUG_MODE) {
      debugLog("CollagePage panel mapping updated:", {
        mappingKeys: Object.keys(panelImageMapping),
        imageCount: selectedImages.length
      });
    }
  }, [panelImageMapping, selectedImages.length]);

  return (
    <>
      <Helmet>
        <title>Collage Tool - Editor - memeSRC</title>
      </Helmet>

      {!authorized ? (
        <UpgradeMessage 
          openSubscriptionDialog={openSubscriptionDialog} 
          previewImage="/assets/images/products/collage-tool.png"
        />
      ) : (
        <MainContainer isMobile={isMobile} isMediumScreen={isMediumScreen}>
          <PageHeader icon={Dashboard} title="Collage Tool" isMobile={isMobile} />
          
          <ContentPaper isMobile={isMobile}>
            <CollageLayout 
              settingsStepProps={settingsStepProps} 
              imagesStepProps={imagesStepProps} 
              isMobile={isMobile}
            />

            {finalImage && (
              <CollageResult 
                finalImage={finalImage} 
                setFinalImage={setFinalImage} 
                isMobile={isMobile} 
                isMediumScreen={isMediumScreen}
                isLoading={isCreatingCollage}
              />
            )}
          </ContentPaper>
        </MainContainer>
      )}
    </>
  );
}


=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/UserContext.js ===

import { createContext } from 'react'

export const UserContext = createContext({
    user: false,
    setUser: () => {},
    shows: [],
    setShows: () => {},
    defaultShow: false,
    handleUpdateDefaultShow: () => {},
    setDefaultShow: () => {},
    handleUpdateUserDetails: () => {}
});

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/contexts/useSubscribeDialog.js ===

// useDialog.js
import { useContext } from 'react';
import { SubscribeDialogContext } from './SubscribeDialog';

export const useSubscribeDialog = () => {
  return useContext(SubscribeDialogContext);
};

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/contexts/SubscribeDialog.js ===

import { AutoFixHighRounded, Block, Close, Favorite, Star, SupportAgent, ExpandMore, Clear, Check, Bolt, Share, ThumbUp, Feedback, ArrowBack, Settings } from '@mui/icons-material';
import { Box, Button, Card, Checkbox, Chip, CircularProgress, Collapse, Dialog, DialogContent, DialogTitle, Divider, Fade, Grid, IconButton, LinearProgress, Typography, useMediaQuery, FormControlLabel, Fab, Stack } from '@mui/material';
import { API, graphqlOperation } from 'aws-amplify';
import { createContext, useState, useRef, useEffect, useContext } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { LoadingButton } from '@mui/lab';
import { UserContext } from '../UserContext';
import useUserLocation from '../utils/geo/useUserLocation';
import { createLocationLeads } from '../graphql/mutations';
import { CountdownTimer } from '../components/CountdownTimer';
import { CURRENT_SALE } from '../constants/sales';

export const SubscribeDialogContext = createContext();

const getInitialPlan = () => {
  const savedPlan = localStorage.getItem('defaultProPlan');
  if (savedPlan) return savedPlan;

  const random = Math.random();
  let selectedPlan;
  
  if (random < 0.2) {
    selectedPlan = 'pro5';  // 20% probability
  } else if (random < 0.75) {
    selectedPlan = 'pro25'; // 55% probability
  } else {
    selectedPlan = 'pro69'; // 25% probability
  }

  localStorage.setItem('defaultProPlan', selectedPlan);
  return selectedPlan;
};

export const DialogProvider = ({ children }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const isXs = useMediaQuery(theme => theme.breakpoints.down('sm'));
  const isMd = useMediaQuery(theme => theme.breakpoints.up('sm'));
  const isCompact = useMediaQuery('(max-width:850px)');
  const [subscriptionDialogOpen, setSubscriptionDialogOpen] = useState(false);
  const [selectedPlan, setSelectedPlan] = useState(getInitialPlan());
  const [loading, setLoading] = useState(false);
  const { user } = useContext(UserContext);
  const [checkoutLink, setCheckoutLink] = useState();
  const [billingAgreement, setBillingAgreement] = useState(false);

  const [askedAboutCredits, setAskedAboutCredits] = useState(false);

  const [selectedTitleSubtitle, setSelectedTitleSubtitle] = useState(null);

  const { countryCode, countryName } = useUserLocation();

  const [creditOptionsExpanded, setCreditOptionsExpanded] = useState(!isCompact);

  useEffect(() => {
    if (location.pathname === '/pro' && user !== null) {
      if (user.userDetails?.subscriptionStatus === 'active') {
        navigate('/account');
      } else {
        setSubscriptionDialogOpen(true);
        navigate('/', { replace: true });
      }
    }
  }, [user, location, navigate, user?.userDetails?.subscriptionStatus]);

  useEffect(() => {
    const randomIndex = Math.floor(Math.random() * titleSubtitlePairs.length);
    setSelectedTitleSubtitle(titleSubtitlePairs[randomIndex]);
  }, []);

  useEffect(() => {
    if (user?.userDetails?.subscriptionStatus === 'active' && subscriptionDialogOpen) {
      closeDialog();
      navigate('/account');
    }
  }, [user?.userDetails?.subscriptionStatus, subscriptionDialogOpen, navigate]);

  useEffect(() => {
    setCreditOptionsExpanded(!isCompact);
  }, [isCompact]);

  const subscribeButtonRef = useRef(null);

  const setSelectedPlanAndScroll = (plan) => {
    setSelectedPlan(plan);
    setAskedAboutCredits(false);
    if (isCompact) {
      setCreditOptionsExpanded(false);
    }
    subscribeButtonRef.current.scrollIntoView({ behavior: 'smooth' });
  };

  const openDialog = (content) => {
    setSubscriptionDialogOpen(true);
  };

  const closeDialog = () => {
    setSubscriptionDialogOpen(false);
    setLoading(false)
    setCheckoutLink()
    setBillingAgreement(false)
  };

  const buySubscription = () => {
    // console.log(selectedPlan)
    setLoading(true)
    API.post('publicapi', '/user/update/getCheckoutSession', {
      body: {
        currentUrl: window.location.href.replace('pro', ''),
        priceKey: selectedPlan
      }
    }).then(results => {
      // console.log(results)
      setCheckoutLink(results)
      setLoading(false)
    }).catch(error => {
      console.log(error.response)
      setLoading(false)
    })
  }

  const titleSubtitlePairs = [
    {
      title: 'Get memeSRC Pro!',
      subtitle: 'Or don\'t. I don\'t care.',
    },
    {
      title: 'Get Pro. Be a Hero.',
      subtitle: 'Or stay basic I guess. Your choice.',
    },
    {
      title: 'Unlock memeSRC Pro!',
      subtitle: "Or forget you ever saw this.",
    },
    {
      title: "Pro is for pros.",
      subtitle: "But don't let that stop you.",
    },
  ];

  const getCreditCount = () => {
    switch (selectedPlan) {
      case 'pro5':
        return 5;
      case 'pro25':
        return 25;
      case 'pro69':
        return 69;
      default:
        return 5;
    }
  };

  const planPrices = {
    pro5: 2.99,
    pro25: 4.99,
    pro69: 6.99,
  };

  const getPriceForPlan = (plan) => {
    const basePrice = planPrices[plan];
    const discountedPrice = CURRENT_SALE.isActive 
      ? basePrice * CURRENT_SALE.discountMultiplier 
      : basePrice;
    return discountedPrice;
  };

  const getColor = () => {
    switch (selectedPlan) {
      case 'pro5':
        return 'primary.main';
      case 'pro25':
        return 'rgb(84, 214, 44)';
      case 'pro69':
        return '#ff6900';
      default:
        return 'primary.main';
    }
  };

  const getTextColor = () => {
    switch (selectedPlan) {
      case 'pro5':
        return 'common.white';
      case 'pro25':
      case 'pro69':
        return 'common.black';
      default:
        return 'common.white';
    }
  };

  const getRandomTitleSubtitle = () => {
    const randomIndex = Math.floor(Math.random() * titleSubtitlePairs.length);
    return titleSubtitlePairs[randomIndex];
  };

  const openSubscriptionDialog = () => {
    setSubscriptionDialogOpen(true)
  }

  const handleLogin = () => {
    setSubscriptionDialogOpen(false);
    navigate('/login?dest=%2Fpro')
  }

  useEffect(() => {
    if (countryCode !== 'US' && countryCode !== 'AU' && countryCode !== 'CA' && checkoutLink) {
      API.graphql(
        graphqlOperation(createLocationLeads, { input: { countryCode } })
      ).then().catch(error => {
        console.log(error)
      })
    }
  }, [countryCode, checkoutLink]);

  const formatPriceDelta = (amount) => {
    const sign = amount >= 0 ? '+' : '-';
    const absAmount = Math.abs(amount);
    const formattedPrice = absAmount % 1 === 0 ? absAmount.toFixed(0) : absAmount.toFixed(2);
    return `${sign}$${formattedPrice}`;
  };

  const toggleCreditOptions = () => {
    if (isCompact) {
      setCreditOptionsExpanded(!creditOptionsExpanded);
    }
  };

  return (
    <SubscribeDialogContext.Provider value={{ openSubscriptionDialog }}>
      {children}
      <Dialog
        open={subscriptionDialogOpen}
        onClose={closeDialog}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
        maxWidth="md"
        fullWidth
        fullScreen={isXs}
        scroll="paper"
        PaperProps={{
          sx: {
            borderRadius: isXs ? 0 : 5,
            backgroundColor: (theme) => theme.palette.common.black,
          },
        }}
      >
        <DialogTitle
          sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            position: 'relative',
            pt: isCompact ? 1.2 : 2,
            pb: isCompact ? 1.2 : 2,
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <img
              src="/assets/memeSRC-white.svg"
              alt="memeSRC logo"
              style={{ height: isCompact ? 24 : 36 }}
            />
            <Typography fontSize={isCompact ? 22 : 28} fontWeight={700}>
              memeSRC Pro
            </Typography>
          </Box>
          <IconButton 
            onClick={closeDialog} 
            size="small" 
            sx={{ 
              position: 'absolute', 
              top: isCompact ? 4 : 8, 
              right: 10, 
              zIndex: 1000, 
              opacity: 0.4 
            }}
          >
            <Close />
          </IconButton>
        </DialogTitle>
        <Divider />
          <>
          {!loading && !checkoutLink && (
            <Fade in timeout={400}>
              <DialogContent sx={{ py: isCompact ? 2 : 4, pb: isCompact ? 3 : 6 }}>
                {CURRENT_SALE.isActive && (isXs || isCompact) && <CountdownTimer />}
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={CURRENT_SALE.isActive ? (isCompact ? 12 : 6) : 12}>
                    <Box
                      p={isCompact ? 2 : 2.5}
                      sx={{
                        backgroundColor: CURRENT_SALE.isActive 
                          ? 'rgba(0, 0, 0, 0.2)' 
                          : getColor(),
                        borderRadius: 4,
                        mb: 2,
                        cursor: 'pointer',
                        position: 'relative',
                        border: CURRENT_SALE.isActive 
                          ? '1px solid rgba(255, 255, 255, 0.1)'
                          : 'none',
                      }}
                      onClick={() => {
                        subscribeButtonRef.current.scrollIntoView({ behavior: 'smooth' });
                      }}
                    >
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Typography 
                          fontSize={isCompact ? 18 : 22}
                          fontWeight={700} 
                          color={CURRENT_SALE.isActive ? 'common.white' : getTextColor()}
                        >
                          {selectedTitleSubtitle?.title}
                        </Typography>
                        {CURRENT_SALE.isActive && (
                          <Chip
                            label={`${(CURRENT_SALE.discountPercent).toFixed(0)}% OFF`}
                            color="error"
                            size="small"
                            sx={{
                              fontWeight: 700,
                              fontSize: '0.85rem',
                              backgroundColor: '#ff1744',
                            }}
                          />
                        )}
                      </Box>
                      <Typography 
                        variant={isCompact ? 'h2' : 'h3'} 
                        mb={0.75}
                        sx={{ color: CURRENT_SALE.isActive ? getColor() : getTextColor() }}
                      >
                        {CURRENT_SALE.isActive && (
                          <span style={{ textDecoration: 'line-through', fontSize: '0.7em', opacity: 0.7, marginRight: '8px', color: 'white' }}>
                            ${planPrices[selectedPlan].toFixed(2)}
                          </span>
                        )}
                        ${getPriceForPlan(selectedPlan).toFixed(2)} / mo.
                      </Typography>
                      <Typography 
                        fontSize={isCompact ? 15 : 13}
                        fontWeight={600} 
                        color={CURRENT_SALE.isActive ? 'common.white' : getTextColor()}
                      >
                        {selectedTitleSubtitle?.subtitle}
                      </Typography>
                    </Box>
                  </Grid>

                  {CURRENT_SALE.isActive && !isXs && !isCompact && (
                    <Grid item sm={6}>
                      <CountdownTimer />
                    </Grid>
                  )}
                </Grid>

                <Grid container spacing={isCompact ? 2 : 4} alignItems="center">
                  <Grid item xs={12} sm={isCompact ? 12 : 5}>
                    <Box display="flex" alignItems="center" mb={isCompact ? 1.5 : 2} ml={2}>
                      <Box
                        sx={{
                          backgroundColor: getColor(),
                          borderRadius: '50%',
                          width: isCompact ? 28 : 32,
                          height: isCompact ? 28 : 32,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          mr: 2,
                        }}
                      >
                        <Check sx={{ color: getTextColor(), fontSize: isCompact ? 20 : 24 }} />
                      </Box>
                      <Typography fontSize={isCompact ? 16 : 18} fontWeight={500}>
                        Zero Ads
                      </Typography>
                    </Box>
                    <Box display="flex" alignItems="center" mb={isCompact ? 1.5 : 2} ml={2}>
                      <Box
                        sx={{
                          backgroundColor: getColor(),
                          borderRadius: '50%',
                          width: isCompact ? 28 : 32,
                          height: isCompact ? 28 : 32,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          mr: 2,
                        }}
                      >
                        <SupportAgent sx={{ color: getTextColor(), fontSize: isCompact ? 20 : 24 }} />
                      </Box>
                      <Typography fontSize={isCompact ? 16 : 18} fontWeight={500}>
                        Pro Support
                      </Typography>
                    </Box>
                    <Box display="flex" alignItems="center" mb={isCompact ? 1.5 : 2} ml={2}>
                      <Box
                        sx={{
                          backgroundColor: getColor(),
                          borderRadius: '50%',
                          width: isCompact ? 28 : 32,
                          height: isCompact ? 28 : 32,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          mr: 2,
                        }}
                      >
                        <Bolt sx={{ color: getTextColor(), fontSize: isCompact ? 20 : 24 }} />
                      </Box>
                      <Typography fontSize={isCompact ? 16 : 18} fontWeight={500}>
                        Exclusive Features
                      </Typography>
                    </Box>
                    <Box 
                      display="flex" 
                      alignItems="center" 
                      ml={2} 
                      onClick={isCompact ? toggleCreditOptions : undefined}
                      sx={{ cursor: isCompact ? 'pointer' : 'default' }}
                    >
                      <Box
                        sx={{
                          backgroundColor: getColor(),
                          borderRadius: '50%',
                          width: isCompact ? 28 : 32,
                          height: isCompact ? 28 : 32,
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          mr: 2,
                        }}
                      >
                        <AutoFixHighRounded sx={{ color: getTextColor(), fontSize: isCompact ? 20 : 24 }} />
                      </Box>
                      <Typography fontSize={isCompact ? 16 : 18} fontWeight={500} sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                        {getCreditCount()} Magic Credits
                        {isCompact && !creditOptionsExpanded && (
                          <Box
                            component="span"
                            sx={{
                              color: 'rgba(255, 255, 255, 0.5)',
                              cursor: 'pointer',
                              ml: 1,
                              fontSize: '0.75em',
                              fontWeight: 600,
                              userSelect: 'none',
                              transition: 'all 0.2s',
                              textDecoration: 'underline',
                              '&:hover': {
                                color: 'rgba(255, 255, 255, 0.8)',
                              }
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              toggleCreditOptions();
                            }}
                          >
                            change
                          </Box>
                        )}
                      </Typography>
                    </Box>
                  </Grid>
                  <Grid item xs={12} sm={isCompact ? 12 : 7}>
                    <Collapse in={creditOptionsExpanded} timeout={300}>
                      {!isCompact ? (
                        <Box sx={{ px: 2 }}>
                          {[
                            { plan: 'pro5', credits: 5, color: 'grey.500', hoverColor: 'grey.500', activeColor: 'grey.500' },
                            { plan: 'pro25', credits: 25, color: 'rgb(84, 214, 44)', hoverColor: 'rgb(84, 214, 44)', activeColor: 'rgb(71, 181, 37)' },
                            { plan: 'pro69', credits: 69, color: '#ff6900', hoverColor: '#ff6900', activeColor: '#e65c00' }
                          ].map(({ plan, credits, color, hoverColor, activeColor }) => (
                            <Card
                              key={plan}
                              variant="outlined"
                              sx={{
                                mb: 2,
                                cursor: 'pointer',
                                borderColor: selectedPlan === plan ? color : 'divider',
                                '&:hover': { borderColor: hoverColor },
                                position: 'relative',
                                overflow: 'hidden',
                              }}
                              onClick={() => setSelectedPlanAndScroll(plan)}
                            >
                              <Box
                                sx={{
                                  position: 'absolute',
                                  top: 0,
                                  left: 0,
                                  width: 8,
                                  height: '100%',
                                  backgroundColor: color,
                                }}
                              />
                              <Box
                                sx={{
                                  p: 2,
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'space-between',
                                  backgroundColor: selectedPlan === plan ? activeColor : 'transparent',
                                  color: selectedPlan === plan ? 'common.black' : 'common.white',
                                }}
                              >
                                <Typography fontSize={18} fontWeight={700} sx={{ ml: 2 }}>
                                  {credits} credits / mo.
                                </Typography>
                                <Typography fontSize={18} fontWeight={700} sx={{ mr: 1 }}>
                                  {selectedPlan === plan
                                    ? 'included'
                                    : formatPriceDelta(getPriceForPlan(plan) - getPriceForPlan(selectedPlan))}
                                </Typography>
                              </Box>
                            </Card>
                          ))}
                        </Box>
                      ) : (
                        <Stack
                          direction="row" 
                          spacing={1}
                          sx={{ 
                            width: '100%', 
                            justifyContent: 'center',
                          }}
                        >
                          {[
                            { plan: 'pro5', credits: 5, color: 'grey.500', textColor: 'common.black' },
                            { plan: 'pro25', credits: 25, color: 'rgb(84, 214, 44)', textColor: 'common.black' },
                            { plan: 'pro69', credits: 69, color: '#ff6900', textColor: 'common.black' }
                          ].map(({ plan, credits, color, textColor }) => (
                            <Box 
                              key={plan} 
                              sx={{ 
                                textAlign: 'center',
                                flex: '1 1 0',
                                minWidth: 0,
                                maxWidth: 160,
                                position: 'relative',
                              }}
                            >
                              <Card
                                variant="outlined"
                                onClick={() => setSelectedPlanAndScroll(plan)}
                                sx={{
                                  height: isCompact ? 54 : 80,
                                  cursor: 'pointer',
                                  borderColor: 'divider',
                                  backgroundColor: selectedPlan === plan ? color : 'grey.800',
                                  position: 'relative',
                                  overflow: 'hidden',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  '&::before': {
                                    content: '""',
                                    position: 'absolute',
                                    top: 0,
                                    left: 0,
                                    width: '100%',
                                    height: '4px',
                                    backgroundColor: color,
                                    display: selectedPlan === plan ? 'none' : 'block'
                                  }
                                }}
                              >
                                <Box 
                                  sx={{ 
                                    display: 'flex', 
                                    alignItems: 'center',
                                    color: selectedPlan === plan ? textColor : 'common.white',
                                    fontSize: isCompact ? '1.2rem' : '1.5rem',
                                    fontWeight: 600,
                                  }}
                                >
                                  <AutoFixHighRounded sx={{ fontSize: isCompact ? 23 : 28, mx: 0.5 }} />
                                  {credits}
                                </Box>
                              </Card>
                              <Typography 
                                variant="caption" 
                                sx={{ 
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  mt: 1, 
                                  color: selectedPlan === plan ? 'common.white' : 'grey.500',
                                  fontWeight: selectedPlan === plan ? 800 : 550,
                                  gap: 0.5,
                                  fontSize: isCompact ? '0.7rem' : '0.75rem',
                                }}
                              >
                                {selectedPlan === plan ? 'included' : 
                                 formatPriceDelta(getPriceForPlan(plan) - getPriceForPlan(selectedPlan))}
                              </Typography>
                            </Box>
                          ))}
                        </Stack>
                      )}
                    </Collapse>
                  </Grid>
                </Grid>
                <Box mt={creditOptionsExpanded || isCompact ? 2 : 4} textAlign="center">
                  {/* {console.log(user)} */}
                  {user?.userDetails ? (
                    <Button
                      ref={subscribeButtonRef}
                      variant="contained"
                      size="large"
                      onClick={() => {
                        if (countryCode === 'US' || countryCode === 'AU' || countryCode === 'CA') {
                          buySubscription();
                        } else {
                          setCheckoutLink('unsupported_country');
                          console.log('unsupported_country')
                        }
                      }}
                      fullWidth
                      sx={{
                        borderRadius: 50,
                        px: 4,
                        py: isCompact ? 1.25 : 1.5,
                        fontSize: isCompact ? 18 : 20,
                        backgroundColor: getColor(),
                        color: getTextColor(),
                      }}
                    >
                      Upgrade Account
                    </Button>
                  ) : (
                    <Button
                      ref={subscribeButtonRef}
                      variant="contained"
                      size="large"
                      onClick={handleLogin}
                      fullWidth
                      sx={{
                        borderRadius: 50,
                        px: 4,
                        py: isCompact ? 1.25 : 1.5,
                        fontSize: isCompact ? 18 : 20,
                        backgroundColor: getColor(),
                        color: getTextColor(),
                      }}
                    >
                      Upgrade Account
                    </Button>
                  )}
                  <Typography
                    variant="caption"
                    color="text.secondary"
                    mx={3}
                    mt={1}
                    sx={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center' }}
                  >
                    <span>Payments to&nbsp;</span>
                    <a
                      href="https://vibehouse.net"
                      target="_blank"
                      rel="noopener noreferrer"
                      style={{ color: '#9e9e9e', textDecoration: 'none' }}
                    >
                      <b>Vibe House</b>
                    </a>
                    <span>&nbsp;secured by&nbsp;</span>
                    <a
                      href="https://stripe.com"
                      target="_blank"
                      rel="noopener noreferrer"
                      style={{ color: '#9e9e9e', textDecoration: 'none' }}
                    >
                      <b>Stripe</b>
                    </a>
                  </Typography>
                </Box>
              </DialogContent>
            </Fade>
          )}
          {(loading || checkoutLink) && (
            <>
            {countryCode !== 'US' && countryCode !== 'AU' && countryCode !== 'CA' && (
          <DialogContent sx={{ py: 4 }}>
            <Box
              p={3}
              sx={{
                backgroundColor: 'error.main',
                borderRadius: 4,
                mb: 4,
              }}
            >
              <Typography fontSize={23} fontWeight={700} color="common.white" gutterBottom>
                Pro is currently not available in your country.
              </Typography>
              <Typography fontSize={14} color="common.white">
                We appreciate your interest and support, but memeSRC&nbsp;Pro is currently unavailable to purchase in your country.
              </Typography>
            </Box>
            <Box sx={{ mt: 4, mx: 2 }}>
              <Typography variant="h6" gutterBottom>
                Other ways to support memeSRC:
              </Typography>
              <Box sx={{ pl: 4, mt: 2 }}>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Box
                    sx={{
                      backgroundColor: 'primary.main',
                      borderRadius: '50%',
                      width: 32,
                      height: 32,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      mr: 2,
                    }}
                  >
                    <Share sx={{ color: 'common.white' }} />
                  </Box>
                  <Typography variant="body1">Help spread the word</Typography>
                </Box>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Box
                    sx={{
                      backgroundColor: 'primary.main',
                      borderRadius: '50%',
                      width: 32,
                      height: 32,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      mr: 2,
                    }}
                  >
                    <ThumbUp sx={{ color: 'common.white' }} />
                  </Box>
                  <Typography variant="body1">Make and share more memes</Typography>
                </Box>
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <Box
                    sx={{
                      backgroundColor: 'primary.main', 
                      borderRadius: '50%',
                      width: 32,
                      height: 32,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      mr: 2,
                    }}
                  >
                    <Feedback sx={{ color: 'common.white' }} />
                  </Box>
                  <Typography variant="body1">Give feedback and contribute</Typography>
                </Box>
              </Box>
            </Box>
            <Box sx={{ mt: 4, mx: 1 }}>
              <Typography variant="body1">
                We love our community around the world and want to keep making these tools more accessible to everyone. We're always trying to support more regions and have noted your interest. Thanks for understanding! 
              </Typography>
            </Box>
            <Button
              ref={subscribeButtonRef}
              variant="contained"
              size="small"
              onClick={closeDialog}
              fullWidth
              sx={{
                borderRadius: 50,
                px: 4,
                fontSize: 17,
                mt: 5,
                // backgroundColor: getColor(),
                // color: getTextColor(),
              }}
            >
              Dismiss
            </Button>
          </DialogContent>
        )}
        {(countryCode === 'US' || countryCode === 'AU' || countryCode === 'CA') && (
          <DialogContent sx={{ minHeight: 500, display: 'flex', flexDirection: 'column', mb: 5 }}>
            <Button
              onClick={() => {
                setCheckoutLink(undefined);
                setLoading(false);
              }}
              sx={{
                color: 'white',
                opacity: 0.7,
                alignSelf: 'flex-start',
                mb: 2,
                '&:hover': {
                  opacity: 1,
                  backgroundColor: 'rgba(255, 255, 255, 0.1)',
                },
              }}
              startIcon={<ArrowBack />}
            >
              Go Back
            </Button>
            <Box sx={{ m: 'auto' }}>
              <Typography fontSize={20} textAlign='center' fontWeight={700}>
                Powered by
              </Typography>
              <Typography fontSize={45} textAlign='center' fontWeight={700} pt={0.5}>
                Vibe House
              </Typography>
              <Box
                sx={{
                  mt: 3,
                  mb: 3,
                  mx: 'auto',
                  p: 2.5,
                  maxWidth: 360,
                  border: '1px solid rgba(255, 255, 255, 0.15)',
                  borderRadius: 2.5,
                  backgroundColor: 'rgba(255, 255, 255, 0.05)',
                  backdropFilter: 'blur(10px)',
                  boxShadow: '0 4px 24px rgba(0, 0, 0, 0.15)',
                }}
              >
                <Typography 
                  fontSize={13}
                  color="text.secondary"
                  sx={{ 
                    mb: 1.5,
                    fontWeight: 500,
                    display: 'flex',
                    alignItems: 'center',
                    gap: 1
                  }}
                >
                  <Typography
                    component="span"
                    sx={{
                      position: 'absolute',
                      top: 0,
                      left: 24,
                      transform: 'translateY(-50%)',
                      backgroundColor: 'background.paper',
                      px: 1,
                      fontSize: 13,
                      fontWeight: 600,
                      color: 'text.secondary',
                      textTransform: 'uppercase',
                      letterSpacing: '0.5px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: 1,
                    }}
                  >
                    <Box 
                      component="span" 
                      sx={{ 
                        width: 8, 
                        height: 8, 
                        borderRadius: '50%', 
                        backgroundColor: 'success.main',
                        animation: 'pulse 2s infinite',
                        '@keyframes pulse': {
                          '0%': { opacity: 0.4 },
                          '50%': { opacity: 1 },
                          '100%': { opacity: 0.4 },
                        }
                      }} 
                    />
                    <b>Reminder</b>
                  </Typography>
                  Your subscription to memeSRC Pro will be billed monthly and appear on your statement as:
                </Typography>
                <Box
                  sx={{
                    p: 1.5,
                    backgroundColor: 'rgba(0, 0, 0, 0.25)',
                    borderRadius: 1.5,
                    border: '1px solid rgba(255, 255, 255, 0.12)',
                    position: 'relative',
                    overflow: 'hidden',
                  }}
                >
                  <Box
                    sx={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      position: 'relative',
                      zIndex: 1,
                    }}
                  >
                    <Typography
                      fontFamily="'Roboto Mono', monospace"
                      fontSize={{ xs: 13, sm: 16 }}
                      fontWeight={700}
                      sx={{ letterSpacing: '0.5px', mx: 1 }}
                    >
                      ${getPriceForPlan(selectedPlan).toFixed(2)}
                    </Typography>
                    <Typography
                      fontFamily="'Roboto Mono', monospace"
                      fontSize={{ xs: 13, sm: 16 }}
                      fontWeight={700}
                      sx={{ 
                        letterSpacing: '0.5px',
                        opacity: 0.85,
                        color: 'white',
                        mx: 1
                      }}
                    >
                      VIBE HOUSE LLC
                    </Typography>
                  </Box>
                  <Box
                    sx={{
                      position: 'absolute',
                      left: 0,
                      top: '50%',
                      width: '100%',
                      height: 1,
                      borderBottom: '2px dotted rgba(255, 255, 255, 0.1)',
                      transform: 'translateY(-50%)',
                    }}
                  />
                </Box>
                <Typography
                  variant="caption"
                  color="text.secondary"
                  sx={{ 
                    display: 'block',
                    mt: 1.5,
                    textAlign: 'center',
                    opacity: 0.7
                  }}
                >
                  Processed securely through Stripe
                </Typography>
              </Box>
            </Box>
            <Box sx={{ mx: 'auto', mt: 'auto', textAlign: 'center' }}>
              <LoadingButton
                loading={loading || !checkoutLink}
                loadingIndicator={
                  <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                    <CircularProgress color="inherit" size={16} sx={{ mr: 1 }} />
                    <span>Preparing&nbsp;Checkout...</span>
                  </Box>
                }
                variant="contained"
                size="large"
                fullWidth
                sx={{
                  borderRadius: 50,
                  px: 0,
                  py: 1.5,
                  fontSize: 20,
                  backgroundColor: getColor(),
                  color: getTextColor(),
                }}
                onClick={() => {
                  window.location.href = checkoutLink;
                }}
              >
                {!loading && checkoutLink ? 'Agree & Continue' : ''}
              </LoadingButton>
              <Typography variant="caption" sx={{ mt: 2, lineHeight: 1.2, }}>
                By continuing, you are confirming: (1) you are a U.S. resident, (2) you understand memeSRC&nbsp;Pro is billed as Vibe&nbsp;House&nbsp;LLC, and you agree to the{' '}
                <a href="/termsofservice" target="_blank" style={{ color: 'white', textDecoration: 'none', fontWeight: 'bold' }}>
                  Terms&nbsp;of&nbsp;Service
                </a>{' '}
                and{' '}
                <a href="/privacypolicy" target="_blank" style={{ color: 'white', textDecoration: 'none', fontWeight: 'bold' }}>
                  Privacy&nbsp;Policy
                </a>
                .
              </Typography>
            </Box>
          </DialogContent>
        )}
            </>
            )}
          </>
      </Dialog>
    </SubscribeDialogContext.Provider>
  );
};


=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/config/CollageConfig.js ===

import React from 'react';
import { 
  layoutDefinitions, 
  getLayoutsForPanelCount, 
  createAutoLayout,
  layoutStyles,
  recommendedLayouts
} from './layouts';

// Aspect ratio presets
export const aspectRatioPresets = [
  { id: 'square', name: 'Square', value: 1 },
  { id: 'portrait', name: 'Portrait', value: 0.8 },
  { id: 'ratio-2-3', name: '2:3', value: 2/3 },
  { id: 'story', name: 'Instagram Story', value: 0.5625 },
  { id: 'classic', name: 'Classic', value: 1.33 },
  { id: 'ratio-3-2', name: '3:2', value: 1.5 },
  { id: 'landscape', name: 'Landscape', value: 1.78 }
];

// Simple Panel component
const SimplePanel = ({ filled, theme }) => (
  <div
    style={{
      width: '100%',
      height: '100%',
      backgroundColor: filled 
        ? (theme?.palette.mode === 'dark' ? 'rgba(25, 118, 210, 0.3)' : 'rgba(25, 118, 210, 0.1)')
        : (theme?.palette.mode === 'dark' ? 'rgba(255, 255, 255, 0.05)' : 'white'),
      border: `1px solid ${theme?.palette.mode === 'dark' ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.12)'}`,
      borderRadius: '4px',
      boxSizing: 'border-box',
    }}
  />
);

// Grid container style
const getBaseGridStyle = (theme) => ({
  width: '100%',
  height: '100%',
  display: 'grid',
  gap: '4px',
  padding: '4px',
  backgroundColor: theme.palette.mode === 'dark' ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.02)',
  borderRadius: theme.shape.borderRadius,
  transition: 'all 0.3s ease',
  boxSizing: 'border-box',
});

// Shared render function for all layouts
const renderLayoutGrid = (layoutConfig, theme, imageCount) => {
  return (
    <div
      style={{
        ...getBaseGridStyle(theme),
        gridTemplateColumns: layoutConfig.gridTemplateColumns,
        gridTemplateRows: layoutConfig.gridTemplateRows,
        gridTemplateAreas: layoutConfig.gridTemplateAreas,
      }}
    >
      {layoutConfig.areas 
        ? layoutConfig.areas.map((area, index) => (
            <div key={index} style={{ gridArea: area }}>
              <SimplePanel theme={theme} filled={imageCount > index} />
            </div>
          ))
        : layoutConfig.items.map((item, index) => (
            <div key={index} style={item}>
              <SimplePanel theme={theme} filled={imageCount > index} />
            </div>
          ))
      }
    </div>
  );
};

/**
 * Main exported layoutTemplates array with Auto Layout and dynamic templates for 2-5 panels
 */
export const layoutTemplates = [
  // Auto Layout - handles cases automatically
  {
    id: 'autoLayout',
    name: 'Auto Layout',
    panels: 5,
    arrangement: 'auto',
    minImages: 2,
    maxImages: 5,
    renderPreview: (aspectRatio, theme, imageCount = 0) => {
      return createAutoLayout(Math.max(2, imageCount || 2), aspectRatio, theme, aspectRatioPresets);
    }
  },
  
  // Dynamic templates for each panel count (2-5)
  ...Array.from({ length: 4 }, (_, i) => i + 2).map(panelCount => ({
    id: `dynamic-${panelCount}-panel`,
    name: `${panelCount} Panel Templates`,
    panels: panelCount,
    arrangement: 'dynamic',
    minImages: panelCount,
    maxImages: panelCount,
    renderPreview: (aspectRatio, theme, imageCount = 0) => {
      const actualImageCount = imageCount || panelCount;
      const closestAspectRatio = aspectRatioPresets.find(preset => preset.value === aspectRatio) || 
                                aspectRatioPresets.find(preset => preset.id === 'square');
      const aspectRatioId = closestAspectRatio?.id || 'square';
      
      // Forward to our layout module system
      const layouts = getLayoutsForPanelCount(panelCount, aspectRatioId);
      if (layouts.length > 0) {
        return layouts[0].renderPreview(aspectRatio, theme, actualImageCount);
      }
      
      // Should never reach here as our layout system is comprehensive
      return createAutoLayout(actualImageCount, aspectRatio, theme, aspectRatioPresets);
    }
  }))
];

// Re-export the getLayoutsForPanelCount function for external use
export { getLayoutsForPanelCount };

// Re-export the layoutStyles and recommendedLayouts for use in UI components
export { layoutStyles, recommendedLayouts }; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/steps/CollageImagesStep.js ===

import { useState, useEffect, useRef } from "react";
import { useTheme } from "@mui/material/styles";
import {
  Box,
  Button,
  Typography,
  Paper,
  useMediaQuery
} from "@mui/material";
import { KeyboardArrowLeft, KeyboardArrowRight, Edit } from "@mui/icons-material";

// Import from the collage configuration
import { aspectRatioPresets, getLayoutsForPanelCount } from "../config/CollageConfig";
// Import new layout rendering utilities
import { 
  renderTemplateToCanvas, 
  getAspectRatioValue,
  calculateCanvasDimensions
} from "../utils/CanvasLayoutRenderer";
// Import panel management utilities
import {
  handlePreviewClick as handlePreviewClickUtil,
  handlePanelImageSelection as handlePanelImageSelectionUtil,
  clearPanelImage as clearPanelImageUtil
} from "../utils/PanelManager";

/**
 * Adjust border thickness based on panel count
 * Scales down thickness significantly as panel count increases
 * @param {number} thickness - Original thickness value
 * @param {number} panelCount - Number of panels in the collage
 * @returns {number} - Adjusted thickness value
 */
const adjustForPanelCount = (thickness, panelCount) => {
  if (panelCount <= 2) {
    return thickness; // No adjustment for 1-2 panels
  }
  
  // Apply a more aggressive scaling for more panels
  let scaleFactor;
  
  switch (panelCount) {
    case 3:
      scaleFactor = 0.7; // 70% of original thickness for 3 panels
      break;
    case 4:
      scaleFactor = 0.6; // 60% of original thickness for 4 panels
      break;
    case 5:
      scaleFactor = 0.5; // 50% of original thickness for 5 panels
      break;
    default:
      scaleFactor = 0.4; // 40% of original thickness for 6+ panels (very aggressive reduction)
      break;
  }
  
  // Ensure minimum thickness of 1 pixel
  return Math.max(1, Math.round(thickness * scaleFactor));
};

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

// Helper debug logger function that only logs when DEBUG_MODE is true
const debugLog = (...args) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Helper for warnings that should still show in production
const debugWarn = (...args) => {
  if (DEBUG_MODE) {
    console.warn(...args);
  } else if (args[0] && args[0].includes('critical')) {
    // Allow critical warnings to show even in production
    console.warn(...args);
  }
};

// Helper for errors that should always show
const logError = (...args) => {
  console.error(...args);
};

/**
 * CollageImagesStep - The second step of the collage creation process
 * Renders a preview of the final collage layout using OffscreenCanvas
 */
const CollageImagesStep = ({ 
  selectedImages, 
  addImage,
  removeImage,
  updateImage,
  clearImages,
  panelCount,
  handleBack, 
  handleNext,
  selectedTemplate,
  selectedAspectRatio,
  borderThickness,
  borderColor,
  borderThicknessOptions,
  panelImageMapping,
  updatePanelImageMapping
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [renderedImage, setRenderedImage] = useState(null);
  // Fallback canvas reference for browsers that don't support OffscreenCanvas
  const canvasRef = useRef(null);
  // Store panel regions for click detection
  const [panelRegions, setPanelRegions] = useState([]);
  // Track which panel was last clicked
  const [selectedPanel, setSelectedPanel] = useState(null);
  // Track initial load state
  const [hasInitialRender, setHasInitialRender] = useState(false);
  // Store selected images per panel - synced with parent component's panelImageMapping
  const [panelToImageMap, setPanelToImageMap] = useState({});
  
  // Enhance the handlePreviewClick function
  const handlePreviewClick = (event) => {
    debugLog("Preview image clicked");
    
    // Get the click coordinates relative to the image
    const image = event.currentTarget;
    const rect = image.getBoundingClientRect();
    
    // Calculate click position as percentage of image dimensions
    const clickX = (event.clientX - rect.left) / rect.width;
    const clickY = (event.clientY - rect.top) / rect.height;
    
    debugLog("Click coordinates as percentage:", { clickX, clickY });
    
    // Convert to canvas coordinates
    const { width, height } = calculateCanvasDimensions(selectedAspectRatio);
    const canvasX = clickX * width;
    const canvasY = clickY * height;
    
    debugLog("Canvas coordinates:", { canvasX, canvasY });
    debugLog("Available panel regions:", panelRegions);
    
    // Find which panel was clicked
    const clickedPanel = panelRegions.find(panel => 
      canvasX >= panel.x && 
      canvasX <= panel.x + panel.width && 
      canvasY >= panel.y && 
      canvasY <= panel.y + panel.height
    );
    
    if (clickedPanel) {
      debugLog(`Clicked on panel ${clickedPanel.id}`);
      setSelectedPanel(clickedPanel);
      
      // Handle the panel selection directly
      handlePanelImageSelection(clickedPanel);
    } else {
      debugLog("No panel was clicked");
    }
  };
  
  // Function to handle image selection for a specific panel
  const handlePanelImageSelection = (panel) => {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        const file = e.target.files[0];
        
        // Convert to base64
        const reader = new FileReader();
        reader.onload = (event) => {
          const base64Image = event.target.result;
          
          // Get border thickness value
          let borderThicknessValue = 4;
          if (borderThicknessOptions && borderThickness) {
            const option = borderThicknessOptions.find(opt => opt.label.toLowerCase() === borderThickness.toLowerCase());
            if (option) {
              borderThicknessValue = option.value;
            }
          }
          
          // Adjust border thickness based on panel count
          const adjustedBorderThickness = adjustForPanelCount(borderThicknessValue, panelCount);
          console.log(`[STEP DEBUG] Image selection: Adjusted border thickness for panelCount ${panelCount}: ${adjustedBorderThickness} (original: ${borderThicknessValue})`);
          
          // Check if this is updating an existing image or adding a new one
          const existingMappingIndex = panelImageMapping[panel.id];
          const isReuploadToSamePanel = existingMappingIndex !== undefined;
          
          // Create direct copies of the data for immediate rendering
          const updatedImages = [...selectedImages];
          const updatedMapping = {...panelImageMapping};
          
          if (isReuploadToSamePanel) {
            // Update existing image
            updatedImages[existingMappingIndex] = base64Image;
            // Update the state
            updateImage(existingMappingIndex, base64Image);
          } else {
            // Add new image
            const newIndex = selectedImages.length;
            updatedImages.push(base64Image);
            updatedMapping[panel.id] = newIndex;
            
            // Update the state
            updatePanelImageMapping(updatedMapping);
            addImage(base64Image);
          }
          
          // DIRECTLY render with the complete data - don't wait for React state updates
          renderTemplateToCanvas({
            selectedTemplate,
            selectedAspectRatio,
            panelCount,
            theme,
            canvasRef,
            setPanelRegions,
            setRenderedImage,
            borderThickness: adjustedBorderThickness,
            borderColor,
            selectedImages: updatedImages,
            panelImageMapping: updatedMapping
          });
          
          // Update the selected panel state
          setSelectedPanel(panel);
        };
        reader.readAsDataURL(file);
      }
    };
    fileInput.click();
  };
  
  // Function to clear image assignment for a panel
  const clearPanelImage = (panelId) => {
    const imageIndex = panelImageMapping[panelId];
    
    if (imageIndex !== undefined) {
      if (DEBUG_MODE) {
        console.log(`Clearing image for panel ${panelId} (image index: ${imageIndex})`);
      }
      
      // Create a new mapping without this panel
      const newMapping = { ...panelImageMapping };
      delete newMapping[panelId];
      
      // Update the mapping
      updatePanelImageMapping(newMapping);
      
      // If this image is not used in any other panel, remove it
      const isImageUsedElsewhere = Object.values(newMapping).includes(imageIndex);
      
      if (!isImageUsedElsewhere) {
        if (DEBUG_MODE) {
          console.log(`Removing image at index ${imageIndex} as it's not used elsewhere`);
        }
        // Remove the image if it's not used elsewhere
        removeImage(imageIndex);
      }
    }
  };
  
  // Keep local panel mapping in sync with parent component
  useEffect(() => {
    // Update our local panel mapping from the parent component
    if (DEBUG_MODE) {
      console.log("Syncing panel image mapping:", panelImageMapping);
    }
    setPanelToImageMap(panelImageMapping);
  }, [panelImageMapping]);

  // Initial setup
  useEffect(() => {
    // Initialize the panel-to-image map from props
    if (Object.keys(panelToImageMap).length === 0 && Object.keys(panelImageMapping).length > 0) {
      if (DEBUG_MODE) {
        console.log("Initializing panel-to-image map from props");
      }
      setPanelToImageMap(panelImageMapping);
    }
  }, []);

  // Single useEffect to handle all rendering scenarios
  /* eslint-disable consistent-return */
  useEffect(() => {
    // Early return if missing required props
    if (!selectedTemplate || !selectedAspectRatio) {
      return;
    }

    console.log(`[STEP DEBUG] CollageImagesStep rendering with panelCount: ${panelCount}, borderThickness: ${borderThickness}, borderColor: ${borderColor}`);
    
    // Get border thickness value
    let borderThicknessValue = 4; // Default
    if (borderThicknessOptions && borderThickness) {
      const option = borderThicknessOptions.find(opt => opt.label.toLowerCase() === borderThickness.toLowerCase());
      if (option) {
        borderThicknessValue = option.value;
        console.log(`[STEP DEBUG] Found matching borderThickness option: ${option.label} = ${borderThicknessValue}`);
      } else {
        console.log(`[STEP DEBUG] No matching option found for borderThickness: ${borderThickness}`);
      }
    } else {
      console.log(`[STEP DEBUG] Using default borderThicknessValue: ${borderThicknessValue}`);
    }
    
    // Adjust border thickness based on panel count
    const adjustedBorderThickness = adjustForPanelCount(borderThicknessValue, panelCount);
    console.log(`[STEP DEBUG] Adjusted border thickness for panelCount ${panelCount}: ${adjustedBorderThickness} (original: ${borderThicknessValue})`);

    // Add short delay for the initial render only
    const initialDelay = hasInitialRender ? 0 : 50;
    
    const timer = setTimeout(() => {
      try {
        console.log(`[STEP DEBUG] Calling renderTemplateToCanvas with borderThickness: ${adjustedBorderThickness}, panelCount: ${panelCount}, borderColor: ${borderColor}`);
        renderTemplateToCanvas({
          selectedTemplate,
          selectedAspectRatio,
          panelCount,
          theme,
          canvasRef,
          setPanelRegions,
          setRenderedImage,
          borderThickness: adjustedBorderThickness,
          borderColor,
          selectedImages,
          panelImageMapping
        });
        
        if (!hasInitialRender) {
          setHasInitialRender(true);
        }
      } catch (error) {
        console.error("Error rendering template:", error);
      }
    }, initialDelay);
    
    return () => clearTimeout(timer);
  }, [
    selectedTemplate, 
    selectedAspectRatio, 
    panelCount, 
    theme.palette.mode, 
    borderThickness,
    borderColor,
    selectedImages, 
    panelImageMapping,
    hasInitialRender
  ]);
  /* eslint-enable consistent-return */

  // Clean up resources when component unmounts
  useEffect(() => {
    // Cleanup function
    return () => {
      if (renderedImage && renderedImage.startsWith('blob:')) {
        URL.revokeObjectURL(renderedImage);
      }
    };
  }, [renderedImage]);

  return (
    <Box sx={{ my: isMobile ? 0 : 0.5 }}>
      {/* Layout Preview */}
      <Paper
        elevation={1}
        sx={{
          p: isMobile ? 1 : 2,
          mb: isMobile ? 1 : 2,
          backgroundColor: theme.palette.background.paper,
          borderRadius: 2,
          textAlign: 'center',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          position: 'relative'
        }}
      >
        {!isMobile && (
          <Typography variant="subtitle2" color="text.secondary" gutterBottom sx={{ mb: 1 }}>
            Preview
          </Typography>
        )}
        
        {renderedImage ? (
          <>
            <Box
              component="img"
              src={renderedImage}
              alt="Collage Layout Preview"
              onClick={handlePreviewClick}
              sx={{
                maxWidth: '100%',
                maxHeight: isMobile ? 300 : 350, // Slightly smaller on mobile
                objectFit: 'contain',
                borderRadius: 1,
                cursor: 'pointer',
                margin: '0 auto',
                display: 'block'
              }}
            />
          </>
        ) : (
          <Box
            sx={{
              height: 180,
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: theme.palette.action.hover,
              borderRadius: 1,
            }}
          >
            <Typography variant="body2" color="text.secondary">
              Generating layout preview...
            </Typography>
          </Box>
        )}
      </Paper>
      
      {/* Hidden canvas fallback for browsers without OffscreenCanvas support */}
      <canvas ref={canvasRef} style={{ display: "none" }} />
    </Box>
  );
};

export default CollageImagesStep;

// Add defaultProps to ensure the component has fallback values
CollageImagesStep.defaultProps = {
  selectedImages: [],
  panelCount: 2,
  selectedAspectRatio: 'portrait',
  borderThickness: 'medium',
  borderThicknessOptions: [
    { label: "None", value: 0 },
    { label: "Thin", value: 0.6 },
    { label: "Medium", value: 1.5 },
  ],
  panelImageMapping: {},
};


=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/steps/CollageSettingsStep.js ===

import { useState, useRef, useEffect } from "react";
import { useTheme, styled, alpha } from "@mui/material/styles";
import {
  Box,
  Button,
  Typography,
  Grid,
  Paper,
  Alert,
  Chip,
  IconButton,
  useMediaQuery,
  Tooltip
} from "@mui/material";
import {
  KeyboardArrowLeft,
  KeyboardArrowRight,
  ChevronLeft,
  ChevronRight,
  AspectRatio,
  GridView,
  Check,
  Add,
  Remove,
  Settings,
  Tag,
  BorderAll,
  Palette,
  Colorize
} from "@mui/icons-material";

// Import styled components
import { TemplateCard } from "../styled/CollageStyled";

// Import layout configuration
import { aspectRatioPresets, layoutTemplates, getLayoutsForPanelCount } from "../config/CollageConfig";

// Color presets for border colors
const COLOR_PRESETS = [
  { color: '#FFFFFF', name: 'White' },
  { color: '#000000', name: 'Black' },
  { color: '#FF0000', name: 'Red' },
  { color: '#0000FF', name: 'Blue' },
  { color: '#FFFF00', name: 'Yellow' },
  { color: '#00FF00', name: 'Green' }
];

// Create a new styled component for aspect ratio cards
const AspectRatioCard = styled(Paper)(({ theme, selected }) => ({
  cursor: 'pointer',
  position: 'relative',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  transition: theme.transitions.create(
    ['border-color', 'background-color', 'box-shadow'],
    { duration: theme.transitions.duration.shorter }
  ),
  border: selected 
    ? `2px solid ${theme.palette.primary.main}` 
    : `1px solid ${theme.palette.divider}`,
  backgroundColor: selected 
    ? alpha(theme.palette.primary.main, theme.palette.mode === 'dark' ? 0.15 : 0.08)
    : theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  '&:hover': {
    boxShadow: selected 
      ? `0 4px 12px ${alpha(theme.palette.primary.main, 0.3)}`
      : theme.palette.mode === 'dark'
        ? '0 4px 12px rgba(0,0,0,0.25)'
        : '0 4px 12px rgba(0,0,0,0.1)',
    borderColor: selected ? theme.palette.primary.main : theme.palette.primary.light
  },
  // Card dimensions
  width: 80,
  height: 80,
  padding: theme.spacing(1),
  flexShrink: 0,
  // Subtle animation on click
  '&:active': {
    transform: 'scale(0.98)',
    transition: 'transform 0.1s',
  }
}));

// Panel Counter component for panel count selector
const PanelCounter = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  gap: theme.spacing(2),
  padding: theme.spacing(1.25), // Reduced padding to decrease height
  backgroundColor: alpha(theme.palette.background.paper, 0.6),
  borderRadius: theme.shape.borderRadius,
  border: `1px solid ${theme.palette.divider}`,
  marginTop: 0,
  marginBottom: theme.spacing(2) // Reduced bottom margin
}));

// Panel Count Button
const PanelCountButton = styled(IconButton)(({ theme }) => ({
  backgroundColor: theme.palette.mode === 'dark' ? alpha(theme.palette.primary.main, 0.2) : alpha(theme.palette.primary.main, 0.08),
  color: theme.palette.primary.main,
  '&:hover': {
    backgroundColor: theme.palette.mode === 'dark' ? alpha(theme.palette.primary.main, 0.3) : alpha(theme.palette.primary.main, 0.15),
  },
  '&.Mui-disabled': {
    backgroundColor: theme.palette.mode === 'dark' ? alpha(theme.palette.action.disabled, 0.2) : alpha(theme.palette.action.disabled, 0.1),
    color: theme.palette.action.disabled,
  }
}));

// Create a new styled component for the action buttons container
const ActionButtonsContainer = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'flex-end',
  marginTop: theme.spacing(3),
}));

// Horizontal scrollable container for horizontal scrolling sections
const HorizontalScroller = styled(Box)(({ theme }) => ({
  display: 'flex',
  overflowX: 'auto',
  overflowY: 'hidden', // Explicitly prevent vertical scrolling
  scrollbarWidth: 'none',  // Firefox
  '&::-webkit-scrollbar': {
    display: 'none',  // Chrome, Safari, Opera
  },
  msOverflowStyle: 'none',  // IE, Edge
  gap: theme.spacing(2),
  padding: theme.spacing(1, 0, 1.25, 0), // Added more bottom padding to accommodate hanging chips
  position: 'relative',
  scrollBehavior: 'smooth',
  alignItems: 'center',  // Center items vertically
  justifyContent: 'flex-start',  // Start alignment for consistent scrolling
  minHeight: 80,  // Reduced height to match content better
  maxWidth: '100%', // Ensure it doesn't exceed container width
  width: '100%', // Take full width of parent
  boxSizing: 'border-box', // Include padding in width calculation
  // Contain content to prevent layout shift
  contain: 'content',
  // Smoother momentum scrolling (for Safari)
  WebkitOverflowScrolling: 'touch',
  // Show that content is scrollable on mobile
  overscrollBehavior: 'contain',
  // Consistent spacing across devices
  [theme.breakpoints.up('sm')]: {
    padding: theme.spacing(1, 0, 1.25, 0), // Added more bottom padding to accommodate hanging chips
    gap: theme.spacing(2), // Consistent gap
  }
}));

// Improved ScrollButton for consistent appearance
const ScrollButton = styled(IconButton)(({ theme, direction }) => ({
  position: 'absolute',
  top: 'calc(50% - 8px)', // Further adjusted to account for the increased bottom padding
  transform: 'translateY(-50%)',
  zIndex: 10,
  // Consistent styling across all devices
  backgroundColor: theme.palette.mode === 'dark' 
    ? alpha(theme.palette.background.paper, 0.8)
    : alpha(theme.palette.background.paper, 0.9),
  // Better shadow for depth without overwhelming the UI
  boxShadow: `0 2px 8px ${theme.palette.mode === 'dark' 
    ? 'rgba(0,0,0,0.3)' 
    : 'rgba(0,0,0,0.15)'}`,
  // Clean border
  border: `1px solid ${theme.palette.mode === 'dark'
    ? alpha(theme.palette.divider, 0.5)
    : theme.palette.divider}`,
  // Primary color for better visibility
  color: theme.palette.primary.main,
  '&:hover': {
    backgroundColor: theme.palette.mode === 'dark' 
      ? alpha(theme.palette.background.paper, 0.9)
      : alpha(theme.palette.background.default, 0.95),
    color: theme.palette.primary.dark,
    transform: 'translateY(-50%) scale(1.05)',
    boxShadow: `0 3px 10px ${theme.palette.mode === 'dark' 
      ? 'rgba(0,0,0,0.4)' 
      : 'rgba(0,0,0,0.2)'}`,
  },
  // Consistent positioning for both directions
  ...(direction === 'left' ? { left: -8 } : { right: -8 }),
  // Consistent sizing across devices
  width: 32,
  height: 32,
  minWidth: 'unset',
  padding: 0,
  // Consistent circular shape on all devices
  borderRadius: '50%',
  // Better transition for hover states
  transition: theme.transitions.create(
    ['background-color', 'color', 'box-shadow', 'transform', 'opacity'], 
    { duration: theme.transitions.duration.shorter }
  ),
  // Same styling for mobile and desktop
  [theme.breakpoints.up('sm')]: {
    width: 36,
    height: 36,
    // Consistent positioning for desktop
    ...(direction === 'left' ? { left: -12 } : { right: -12 }),
  }
}));

// Improved ScrollIndicator with subtle gradient
const ScrollIndicator = styled(Box, {
  shouldForwardProp: (prop) => prop !== 'isVisible'
})(({ theme, direction, isVisible }) => ({
  position: 'absolute',
  top: 0,
  bottom: 0,
  width: 40, // Slightly narrower for subtlety
  pointerEvents: 'none',
  zIndex: 2,
  opacity: isVisible ? 1 : 0,
  transition: 'opacity 0.3s ease',
  background: direction === 'left'
    ? `linear-gradient(90deg, ${theme.palette.mode === 'dark' 
        ? 'rgba(25,25,25,0.9)' 
        : 'rgba(255,255,255,0.9)'} 0%, transparent 100%)`
    : `linear-gradient(270deg, ${theme.palette.mode === 'dark' 
        ? 'rgba(25,25,25,0.9)' 
        : 'rgba(255,255,255,0.9)'} 0%, transparent 100%)`,
  ...(direction === 'left' ? { left: 0 } : { right: 0 })
}));

const StepSectionHeading = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  marginBottom: theme.spacing(0.75),
  paddingLeft: theme.spacing(0.5),
  paddingRight: theme.spacing(0.5),
}));

// Helper function to convert aspect ratio value to a friendly format
const getFriendlyAspectRatio = (value) => {
  if (value === 1) return '1:1';
  
  // Common aspect ratios with friendly names
  if (Math.abs(value - 0.8) < 0.01) return '4:5';      // Portrait
  if (Math.abs(value - 2/3) < 0.01) return '2:3';      // Added 2:3 ratio
  if (Math.abs(value - 0.5625) < 0.01) return '9:16';  // Instagram Story
  if (Math.abs(value - 1.33) < 0.01) return '4:3';     // Classic
  if (Math.abs(value - 1.5) < 0.01) return '3:2';      // Added 3:2 ratio
  if (Math.abs(value - 1.78) < 0.01) return '16:9';    // Landscape
  
  // For other values, find the closest simple fraction
  if (value > 1) {
    // Landscape orientation
    return `${Math.round(value)}:1`;
  }
  // Portrait orientation
  return `1:${Math.round(1/value)}`;
};

// Create a color swatch component for border color selection
const ColorSwatch = styled(Box)(({ theme, selected }) => ({
  width: 36,
  height: 36,
  borderRadius: '50%',
  cursor: 'pointer',
  boxSizing: 'border-box',
  border: selected ? `3px solid ${theme.palette.primary.main}` : '2px solid #ffffff',
  boxShadow: selected 
    ? `0 0 0 2px ${theme.palette.primary.main}` 
    : '0 0 0 1px rgba(0,0,0,0.1)',
  transition: theme.transitions.create(
    ['transform', 'box-shadow'],
    { duration: theme.transitions.duration.shorter }
  ),
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexShrink: 0,
  '&:hover': {
    transform: 'scale(1.15)',
    boxShadow: '0 4px 10px rgba(0,0,0,0.15)'
  },
  '&:active': {
    transform: 'scale(0.95)',
  }
}));

// Custom color picker input - hidden but accessible
const ColorPickerInput = styled('input')(({ theme }) => ({
  opacity: 0,
  position: 'absolute',
  pointerEvents: 'none',
  height: 0,
  width: 0,
}));

// Helper function to determine if a color is dark (for contrast)
const isDarkColor = (hexColor) => {
  // Convert hex to RGB
  const r = parseInt(hexColor.substr(1, 2), 16);
  const g = parseInt(hexColor.substr(3, 2), 16);
  const b = parseInt(hexColor.substr(5, 2), 16);
  
  // Calculate brightness (YIQ formula)
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  
  // Return true if color is dark
  return brightness < 128;
};

// Renamed component to CollageLayoutSettings
const CollageLayoutSettings = ({ 
  selectedImages, 
  selectedTemplate, 
  setSelectedTemplate, 
  selectedAspectRatio, 
  setSelectedAspectRatio,
  panelCount,
  setPanelCount,
  handleNext,
  aspectRatioPresets,
  layoutTemplates,
  borderThickness,
  setBorderThickness,
  borderColor,
  setBorderColor,
  borderThicknessOptions
}) => {
  // State for scroll indicators
  const [aspectLeftScroll, setAspectLeftScroll] = useState(false);
  const [aspectRightScroll, setAspectRightScroll] = useState(false);
  const [layoutLeftScroll, setLayoutLeftScroll] = useState(false);
  const [layoutRightScroll, setLayoutRightScroll] = useState(false);
  const [borderLeftScroll, setBorderLeftScroll] = useState(false);
  const [borderRightScroll, setBorderRightScroll] = useState(false);
  const [colorLeftScroll, setColorLeftScroll] = useState(false);
  const [colorRightScroll, setColorRightScroll] = useState(false);
  
  // Refs for scrollable containers
  const aspectRatioRef = useRef(null);
  const layoutsRef = useRef(null);
  const borderThicknessRef = useRef(null);
  const borderColorRef = useRef(null);
  const colorPickerRef = useRef(null);
  
  // Theme and responsive helpers
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  
  // Get aspect ratio value based on selected preset
  const getAspectRatioValue = () => {
    const preset = aspectRatioPresets.find(p => p.id === selectedAspectRatio);
    return preset ? preset.value : 1;
  };
  
  // Get compatible templates based on panel count
  const getCompatibleTemplates = () => {
    // Use our new getLayoutsForPanelCount function if it exists, otherwise fall back
    if (typeof getLayoutsForPanelCount === 'function') {
      return getLayoutsForPanelCount(panelCount, selectedAspectRatio);
    }
    
    // Legacy fallback (should not be needed once updated)
    return layoutTemplates.filter(template => 
      template.minImages <= panelCount && template.maxImages >= panelCount
    );
  };
  
  // Handle aspect ratio change
  const handleSelectAspectRatio = (aspectRatioId) => {
    setSelectedAspectRatio(aspectRatioId);
    
    // Get templates optimized for the new aspect ratio
    const newCompatibleTemplates = (typeof getLayoutsForPanelCount === 'function') 
      ? getLayoutsForPanelCount(panelCount, aspectRatioId)
      : compatibleTemplates;
      
    // If we have templates, select the most suitable one
    if (newCompatibleTemplates.length > 0) {
      // The templates should already be prioritized based on aspect ratio suitability
      // The most suitable template for this aspect ratio will be first in the list
      setSelectedTemplate(newCompatibleTemplates[0]);
    }
  };
  
  // Handle template selection
  const handleTemplateClick = (template) => {
    // Check compatibility - templates from getLayoutsForPanelCount are always compatible
    const isCompatible = template.minImages <= panelCount && template.maxImages >= panelCount;
    if (isCompatible) {
      setSelectedTemplate(template);
    }
  };

  // Handle panel count changes
  const handlePanelCountIncrease = () => {
    if (panelCount < 5) {
      const newCount = panelCount + 1;
      setPanelCount(newCount);
      
      // Get optimized templates for the new panel count
      const newTemplates = (typeof getLayoutsForPanelCount === 'function')
        ? getLayoutsForPanelCount(newCount, selectedAspectRatio)
        : layoutTemplates.filter(t => t.minImages <= newCount && t.maxImages >= newCount);
      
      // Select the best template for the new panel count
      if (newTemplates.length > 0) {
        setSelectedTemplate(newTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  };

  const handlePanelCountDecrease = () => {
    if (panelCount > 2) {
      const newCount = panelCount - 1;
      setPanelCount(newCount);
      
      // Get optimized templates for the new panel count
      const newTemplates = (typeof getLayoutsForPanelCount === 'function')
        ? getLayoutsForPanelCount(newCount, selectedAspectRatio)
        : layoutTemplates.filter(t => t.minImages <= newCount && t.maxImages >= newCount);
      
      // Select the best template for the new panel count
      if (newTemplates.length > 0) {
        setSelectedTemplate(newTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  };
  
  // Function to improve scroll experience - refactored for smooth and consistent behavior
  const scrollLeft = (ref) => {
    if (ref.current) {
      // Calculate a consistent scroll distance based on container width
      const scrollDistance = Math.min(ref.current.clientWidth * 0.5, 250);
      ref.current.scrollBy({ left: -scrollDistance, behavior: 'smooth' });
      
      // Update scroll indicators after scrolling
      setTimeout(() => {
        if (ref === aspectRatioRef) {
          handleAspectScroll();
        } else if (ref === layoutsRef) {
          handleLayoutScroll();
        } else if (ref === borderThicknessRef) {
          handleBorderScroll();
        } else if (ref === borderColorRef) {
          handleColorScroll();
        }
      }, 350); // Slightly longer timeout to ensure scroll completes
    }
  };
  
  const scrollRight = (ref) => {
    if (ref.current) {
      // Calculate a consistent scroll distance based on container width
      const scrollDistance = Math.min(ref.current.clientWidth * 0.5, 250);
      ref.current.scrollBy({ left: scrollDistance, behavior: 'smooth' });
      
      // Update scroll indicators after scrolling
      setTimeout(() => {
        if (ref === aspectRatioRef) {
          handleAspectScroll();
        } else if (ref === layoutsRef) {
          handleLayoutScroll();
        } else if (ref === borderThicknessRef) {
          handleBorderScroll();
        } else if (ref === borderColorRef) {
          handleColorScroll();
        }
      }, 350); // Slightly longer timeout to ensure scroll completes
    }
  };

  // Check if scrolling is needed and update indicator states
  const checkScrollPosition = (ref, setLeftScroll, setRightScroll) => {
    if (!ref.current) return;
    
    const { scrollLeft, scrollWidth, clientWidth } = ref.current;
    const hasLeft = scrollLeft > 5; // Use a small threshold to detect left scrollability
    const hasRight = scrollLeft < scrollWidth - clientWidth - 5; // Use a small threshold to detect right scrollability
    
    setLeftScroll(hasLeft);
    setRightScroll(hasRight);
  };

  // Define scroll handler functions outside useEffect for accessibility in cleanup
  const handleAspectScroll = () => {
    checkScrollPosition(aspectRatioRef, setAspectLeftScroll, setAspectRightScroll);
  };
  
  const handleLayoutScroll = () => {
    checkScrollPosition(layoutsRef, setLayoutLeftScroll, setLayoutRightScroll);
  };

  // Handle border thickness change
  const handleBorderScroll = () => {
    checkScrollPosition(borderThicknessRef, setBorderLeftScroll, setBorderRightScroll);
  };
  
  // Handle scrolling for color options
  const handleColorScroll = () => {
    checkScrollPosition(borderColorRef, setColorLeftScroll, setColorRightScroll);
  };
  
  // Handle custom color selection
  const handleCustomColorChange = (e) => {
    const newColor = e.target.value;
    setBorderColor(newColor);
    setSavedCustomColor(newColor);
    localStorage.setItem('memeCollageBorderCustomColor', newColor);
  };
  
  // Check scroll positions on initial render and window resize
  useEffect(() => {
    // Initial check of scroll positions
    handleAspectScroll();
    handleLayoutScroll();
    handleBorderScroll();
    handleColorScroll();
    
    // Add resize listener to update scroll indicators
    const handleResize = () => {
      handleAspectScroll();
      handleLayoutScroll();
      handleBorderScroll();
      handleColorScroll();
    };
    
    // Add scroll event listeners to both containers
    const aspectRatioElement = aspectRatioRef.current;
    const layoutsElement = layoutsRef.current;
    const borderThicknessElement = borderThicknessRef.current;
    const borderColorElement = borderColorRef.current;
    
    if (aspectRatioElement) {
      aspectRatioElement.addEventListener('scroll', handleAspectScroll);
    }
    
    if (layoutsElement) {
      layoutsElement.addEventListener('scroll', handleLayoutScroll);
    }
    
    if (borderThicknessElement) {
      borderThicknessElement.addEventListener('scroll', handleBorderScroll);
    }
    
    if (borderColorElement) {
      borderColorElement.addEventListener('scroll', handleColorScroll);
    }
    
    window.addEventListener('resize', handleResize);
    
    // Clean up event listeners
    return () => {
      if (aspectRatioElement) {
        aspectRatioElement.removeEventListener('scroll', handleAspectScroll);
      }
      
      if (layoutsElement) {
        layoutsElement.removeEventListener('scroll', handleLayoutScroll);
      }
      
      if (borderThicknessElement) {
        borderThicknessElement.removeEventListener('scroll', handleBorderScroll);
      }
      
      if (borderColorElement) {
        borderColorElement.removeEventListener('scroll', handleColorScroll);
      }
      
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  // Update scroll indicators when content or panel count changes
  useEffect(() => {
    handleAspectScroll();
    
    // Small delay to ensure layout has updated
    setTimeout(() => {
      handleAspectScroll();
    }, 100);
  }, [selectedAspectRatio, panelCount]);
  
  // Update layout scroll indicators when templates or panel count changes
  useEffect(() => {
    handleLayoutScroll();
    
    // Small delay to ensure layout has updated
    setTimeout(() => {
      handleLayoutScroll();
    }, 100);
  }, [selectedTemplate, panelCount]);
  
  // Update border thickness scroll indicators when options change
  useEffect(() => {
    handleBorderScroll();
    
    // Small delay to ensure layout has updated
    setTimeout(() => {
      handleBorderScroll();
    }, 100);
  }, [borderThickness, borderThicknessOptions]);
  
  // Update border color scroll indicators
  useEffect(() => {
    handleColorScroll();
    
    // Small delay to ensure layout has updated
    setTimeout(() => {
      handleColorScroll();
    }, 100);
  }, [borderColor]);
  
  // Render aspect ratio preview
  const renderAspectRatioPreview = (preset) => {
    const { value, name } = preset;
    
    // Calculate dimensions based on the aspect ratio value
    const friendlyRatio = getFriendlyAspectRatio(value);
  
    // Determine box dimensions to exactly match the aspect ratio
    const isPortrait = value < 1;
    let width;
    let height;
    
    if (isPortrait) {
      // For portrait: height is fixed at 60%, width is calculated to match aspect ratio
      height = 60; 
      width = height * value; // width = height * (width/height)
    } else {
      // For landscape or square: width is fixed at 60%, height is calculated to match aspect ratio
      width = 60;
      height = width / value; // height = width / (width/height)
    }
    
    return (
      <Box sx={{ 
        position: 'relative', 
        width: '100%', 
        height: '100%', 
        display: 'flex', 
        flexDirection: 'column',
        alignItems: 'center', 
        justifyContent: 'center',
        padding: 0.5
      }}>
        <Box 
          sx={{
            width: `${width}%`,
            height: `${height}%`,
            border: theme => `2px solid ${alpha(
              theme.palette.mode === 'dark' 
                ? theme.palette.primary.light 
                : theme.palette.primary.main, 
              0.8
            )}`,
            borderRadius: 1,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: theme => alpha(
              theme.palette.mode === 'dark' 
                ? theme.palette.primary.dark 
                : theme.palette.primary.light, 
              0.15
            ),
            boxShadow: '0px 2px 4px rgba(0,0,0,0.1)'
          }}
        />
      </Box>
    );
  };

  const compatibleTemplates = getCompatibleTemplates();
  const selectedAspectRatioObj = aspectRatioPresets.find(p => p.id === selectedAspectRatio);
  
  // Clean up all the duplicate state variables and use a single savedCustomColor state
  const [savedCustomColor, setSavedCustomColor] = useState(() => {
    // Initialize from localStorage or use white as default
    const storedColor = localStorage.getItem('memeCollageBorderCustomColor');
    return storedColor || '#FFFFFF';
  });
  
  // Check if current color is a custom color (not in the preset colors)
  const isCustomColor = !COLOR_PRESETS.some(c => c.color === borderColor);
  
  // Check if there's a saved custom color that's different from preset colors
  const hasSavedCustomColor = savedCustomColor && !COLOR_PRESETS.some(c => c.color === savedCustomColor);
  
  // Effect to update localStorage when custom color changes
  useEffect(() => {
    if (isCustomColor) {
      setSavedCustomColor(borderColor);
      localStorage.setItem('memeCollageBorderCustomColor', borderColor);
    }
  }, [borderColor, isCustomColor]);
  
  return (
    <Box sx={{ pt: 0 }}>
      {/* Panel Count Selector - Moved to the top */}
      <Box sx={{ mb: isMobile ? 0 : 1 }}>
        <StepSectionHeading>
          <Tag sx={{ 
            mr: 1.5, 
            color: '#fff', 
            fontSize: '1.3rem' 
          }} />
          <Typography variant="h5" fontWeight={600} sx={{ color: '#fff' }}>
            Panel Count
          </Typography>
        </StepSectionHeading>
        
        <PanelCounter>
          <PanelCountButton 
            aria-label="Decrease panel count" 
            disabled={panelCount <= 2}
            onClick={handlePanelCountDecrease}
            size="medium"
            sx={{
              color: '#fff',
              bgcolor: 'rgba(255, 255, 255, 0.15)',
              '&:hover': {
                bgcolor: 'rgba(255, 255, 255, 0.25)',
              },
              width: 32,
              height: 32,
              padding: 0.5
            }}
          >
            <Remove />
          </PanelCountButton>
          
          <Typography variant="h4" sx={{ 
            minWidth: 50, 
            textAlign: 'center',
            fontWeight: 700,
            color: '#fff',
            fontSize: '2rem',
            textShadow: '0px 2px 3px rgba(0,0,0,0.1)'
          }}>
            {panelCount}
          </Typography>
          
          <PanelCountButton 
            aria-label="Increase panel count" 
            disabled={panelCount >= 5}
            onClick={handlePanelCountIncrease}
            size="medium"
            sx={{
              color: '#fff',
              bgcolor: 'rgba(255, 255, 255, 0.15)',
              '&:hover': {
                bgcolor: 'rgba(255, 255, 255, 0.25)',
              },
              width: 32,
              height: 32,
              padding: 0.5
            }}
          >
            <Add />
          </PanelCountButton>
        </PanelCounter>
      </Box>
    
      {/* Aspect Ratio Section - with horizontal scrolling */}
      <Box sx={{ mb: isMobile ? 1 : 2 }}>
        <StepSectionHeading>
          <AspectRatio sx={{ 
            mr: 1.5, 
            color: '#fff', 
            fontSize: '1.3rem' 
          }} />
          <Typography variant="h5" fontWeight={600} sx={{ color: '#fff' }}>
            Aspect Ratio
          </Typography>
        </StepSectionHeading>
        
        <Box sx={{ 
          position: 'relative', 
          width: '100%',
          // Consistent padding for container
          mt: 1,
          pt: 0.5, 
          pb: 0.5,
          // Consistent styling across devices
          [theme.breakpoints.up('sm')]: {
            width: '100%', // Full width container
            mt: 1, // Consistent margin
            pt: 0.5,
            pb: 0.5
          }
        }}>
          <ScrollButton 
            direction="left" 
            onClick={() => scrollLeft(aspectRatioRef)} 
            size="small"
            aria-label="Scroll left"
            sx={{ 
              // Always display buttons for consistency, just disable them
              display: 'flex',
              visibility: aspectLeftScroll ? 'visible' : 'hidden',
              opacity: aspectLeftScroll ? 1 : 0,
            }}
          >
            <ChevronLeft fontSize="small" />
          </ScrollButton>
          
          <ScrollButton 
            direction="right" 
            onClick={() => scrollRight(aspectRatioRef)} 
            size="small"
            aria-label="Scroll right"
            sx={{ 
              // Always display buttons for consistency, just disable them
              display: 'flex',
              visibility: aspectRightScroll ? 'visible' : 'hidden',
              opacity: aspectRightScroll ? 1 : 0,
            }}
          >
            <ChevronRight fontSize="small" />
          </ScrollButton>
          
          <HorizontalScroller 
            ref={aspectRatioRef}
            sx={{ pt: 0, mt: 0 }}
          >
            {aspectRatioPresets.map(preset => (
              <AspectRatioCard
                key={preset.id}
                selected={selectedAspectRatio === preset.id}
                onClick={() => handleSelectAspectRatio(preset.id)}
                elevation={selectedAspectRatio === preset.id ? 3 : 1}
                sx={{ mb: 0 }} // Remove margin bottom as the HorizontalScroller now has padding
              >
                {renderAspectRatioPreview(preset)}
                
                {selectedAspectRatio === preset.id && (
                  <Box 
                    sx={{ 
                      position: 'absolute', 
                      top: 4, 
                      right: 4, 
                      bgcolor: 'primary.main',
                      borderRadius: '50%',
                      width: 20,
                      height: 20,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    <Check sx={{ fontSize: 14, color: 'white' }} />
                  </Box>
                )}
                
                <Chip
                  label={getFriendlyAspectRatio(preset.value)}
                  size="small"
                  variant="filled"
                  sx={{
                    position: 'absolute',
                    bottom: -8,
                    left: '50%',
                    transform: 'translateX(-50%)',
                    height: 18,
                    fontSize: '0.65rem',
                    fontWeight: 'bold',
                    px: 0.75,
                    backgroundColor: theme => selectedAspectRatio === preset.id 
                      ? theme.palette.primary.main
                      : theme.palette.mode === 'dark' 
                        ? 'rgba(255, 255, 255, 0.15)' 
                        : 'rgba(0, 0, 0, 0.08)',
                    color: theme => selectedAspectRatio === preset.id 
                      ? theme.palette.primary.contrastText
                      : theme.palette.text.primary,
                    '& .MuiChip-label': {
                      px: 0.75,
                      py: 0
                    }
                  }}
                />
              </AspectRatioCard>
            ))}
            
            {/* Spacer to ensure last items can be centered when scrolled fully */}
            <Box sx={{ minWidth: 4, flexShrink: 0 }} />
          </HorizontalScroller>
          
          {/* Visual indicators for scrolling - simplified with no icons */}
          <ScrollIndicator 
            direction="left" 
            isVisible={aspectLeftScroll}
          />
          
          <ScrollIndicator 
            direction="right" 
            isVisible={aspectRightScroll}
          />
        </Box>
      </Box>
      
      {/* Layout Section - shows compatible layouts based on panel count */}
      <Box sx={{ mb: isMobile ? 1 : 2 }}>
        <StepSectionHeading>
          <GridView sx={{ 
            mr: 1.5, 
            color: '#fff', 
            fontSize: '1.3rem' 
          }} />
          <Typography variant="h5" fontWeight={600} sx={{ color: '#fff' }}>
            Layout
          </Typography>
        </StepSectionHeading>
        
        {compatibleTemplates.length === 0 ? (
          <Alert severity="info" sx={{ mb: 1 }}>
            No templates match the current panel count ({panelCount}). Try a different number of panels.
          </Alert>
        ) : (
          <Box sx={{ 
            position: 'relative', 
            width: '100%',
            // Consistent padding for container
            mt: 1,
            pt: 0.5, 
            pb: 0.5,
            // Consistent styling across devices
            [theme.breakpoints.up('sm')]: {
              width: '100%', // Full width container
              mt: 1, // Consistent margin
              pt: 0.5,
              pb: 0.5
            }
          }}>
            <ScrollButton 
              direction="left" 
              onClick={() => scrollLeft(layoutsRef)} 
              size="small"
              aria-label="Scroll left"
              sx={{ 
                // Always display buttons for consistency, just disable them
                display: 'flex',
                visibility: layoutLeftScroll ? 'visible' : 'hidden',
                opacity: layoutLeftScroll ? 1 : 0,
              }}
            >
              <ChevronLeft fontSize="small" />
            </ScrollButton>
            
            <ScrollButton 
              direction="right" 
              onClick={() => scrollRight(layoutsRef)} 
              size="small"
              aria-label="Scroll right"
              sx={{ 
                // Always display buttons for consistency, just disable them
                display: 'flex',
                visibility: layoutRightScroll ? 'visible' : 'hidden',
                opacity: layoutRightScroll ? 1 : 0,
              }}
            >
              <ChevronRight fontSize="small" />
            </ScrollButton>
            
            <HorizontalScroller 
              ref={layoutsRef}
              sx={{ pt: 0, mt: 0 }}
            >
              {compatibleTemplates.map(template => {
                const isSelected = selectedTemplate?.id === template.id;
                const aspectRatioValue = getAspectRatioValue();
                
                return (
                  <Box
                    key={template.id}
                    sx={{ 
                      flexShrink: 0,
                      // Use same dimensions as AspectRatioCard for consistency
                      width: 80,
                      height: 80,
                    }}
                  >
                    <TemplateCard
                      selected={isSelected}
                      onClick={() => handleTemplateClick(template)}
                      sx={{
                        width: '100%',
                        height: '100%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        padding: theme.spacing(1),
                        transition: theme.transitions.create(
                          ['border-color', 'background-color', 'box-shadow'],
                          { duration: theme.transitions.duration.shorter }
                        ),
                        '&:hover': {
                          boxShadow: isSelected 
                            ? `0 4px 12px ${alpha(theme.palette.primary.main, 0.3)}`
                            : theme.palette.mode === 'dark'
                              ? '0 4px 12px rgba(0,0,0,0.25)'
                              : '0 4px 12px rgba(0,0,0,0.1)',
                        },
                        '&:active': {
                          transform: 'scale(0.98)',
                          transition: 'transform 0.1s',
                        }
                      }}
                    >
                      {/* Container to properly handle aspect ratio */}
                      <Box 
                        sx={{ 
                          position: 'relative',
                          width: '100%',
                          height: '100%',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                        }}
                      >
                        {/* Aspect ratio constraining box */}
                        <Box
                          sx={{
                            position: 'relative',
                            width: aspectRatioValue >= 1 ? '85%' : `${85 * aspectRatioValue}%`,
                            height: aspectRatioValue >= 1 ? `${85 / aspectRatioValue}%` : '85%',
                          }}
                        >
                          {template.renderPreview(aspectRatioValue, theme, panelCount)}
                        </Box>
                      </Box>
                      
                      {isSelected && (
                        <Box 
                          sx={{ 
                            position: 'absolute', 
                            top: 4, 
                            right: 4, 
                            bgcolor: 'primary.main',
                            borderRadius: '50%',
                            width: 20,
                            height: 20,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                          }}
                        >
                          <Check sx={{ fontSize: 14, color: 'white' }} />
                        </Box>
                      )}
                    </TemplateCard>
                  </Box>
                );
              })}
              
              {/* Spacer to ensure last items can be centered when scrolled fully */}
              <Box sx={{ minWidth: 4, flexShrink: 0 }} />
            </HorizontalScroller>
            
            {/* Visual indicators for scrolling - simplified with no icons */}
            <ScrollIndicator 
              direction="left" 
              isVisible={layoutLeftScroll}
            />
            
            <ScrollIndicator 
              direction="right" 
              isVisible={layoutRightScroll}
            />
          </Box>
        )}
      </Box>
      
      {/* Border Thickness UI with Horizontal Scroller - Moved below Choose Layout */}
      <Box sx={{ mb: isMobile ? 0.25 : 0.5, position: 'relative' }}>
        <StepSectionHeading sx={{ mb: 0.5 }}>
          <BorderAll sx={{ mr: 1, color: '#fff', fontSize: '1.3rem' }} />
          <Typography variant="h5" fontWeight={600} sx={{ color: '#fff' }}>
            Borders
          </Typography>
        </StepSectionHeading>

        <Box sx={{ 
          position: 'relative', 
          width: '100%',
          mt: 0.5,
          pt: 0, 
          pb: 0,
          [theme.breakpoints.up('sm')]: {
            width: '100%',
            mt: 0.5,
            pt: 0,
            pb: 0
          }
        }}>
          {/* Border Width Scroller */}
          <Box sx={{ position: 'relative', mb: 0 }}>
            <ScrollButton 
              direction="left" 
              onClick={() => scrollLeft(borderThicknessRef)} 
              size="small"
              aria-label="Scroll left"
              sx={{ 
                display: 'flex',
                visibility: borderLeftScroll ? 'visible' : 'hidden',
                opacity: borderLeftScroll ? 1 : 0,
                top: '50%',
                transform: 'translateY(-50%)',
              }}
            >
              <ChevronLeft fontSize="small" />
            </ScrollButton>
            
            <ScrollButton 
              direction="right" 
              onClick={() => scrollRight(borderThicknessRef)} 
              size="small"
              aria-label="Scroll right"
              sx={{ 
                display: 'flex',
                visibility: borderRightScroll ? 'visible' : 'hidden',
                opacity: borderRightScroll ? 1 : 0,
                top: '50%',
                transform: 'translateY(-50%)',
              }}
            >
              <ChevronRight fontSize="small" />
            </ScrollButton>

            <Box 
              ref={borderThicknessRef}
              onScroll={handleBorderScroll}
              sx={{ 
                display: 'flex',
                overflowX: 'auto',
                scrollbarWidth: 'none',
                '&::-webkit-scrollbar': { display: 'none' },
                gap: theme.spacing(1),
                py: 0.25,
                mt: 0,
                minHeight: 40
              }}
            >
              {borderThicknessOptions.map((option, index) => {
                const fontWeight = option.label === "None" ? 400 : 400 + (index * 100);
                
                return (
                  <Chip
                    key={option.label}
                    label={option.label}
                    clickable
                    color={borderThickness === option.label.toLowerCase() ? 'primary' : 'default'}
                    onClick={() => setBorderThickness(option.label.toLowerCase())}
                    sx={{ 
                      fontWeight: borderThickness === option.label.toLowerCase() ? 
                        fontWeight + 100 : fontWeight 
                    }}
                  />
                );
              })}
            </Box>
            
            <ScrollIndicator 
              direction="left" 
              isVisible={borderLeftScroll}
            />
            
            <ScrollIndicator 
              direction="right" 
              isVisible={borderRightScroll}
            />
          </Box>

          {/* Border Color Scroller */}
          <Box sx={{ position: 'relative' }}>
            <ScrollButton 
              direction="left" 
              onClick={() => scrollLeft(borderColorRef)} 
              size="small"
              aria-label="Scroll left"
              sx={{ 
                display: 'flex',
                visibility: colorLeftScroll ? 'visible' : 'hidden',
                opacity: colorLeftScroll ? 1 : 0,
                top: '50%',
                transform: 'translateY(-50%)',
              }}
            >
              <ChevronLeft fontSize="small" />
            </ScrollButton>
            
            <ScrollButton 
              direction="right" 
              onClick={() => scrollRight(borderColorRef)} 
              size="small"
              aria-label="Scroll right"
              sx={{ 
                display: 'flex',
                visibility: colorRightScroll ? 'visible' : 'hidden',
                opacity: colorRightScroll ? 1 : 0,
                top: '50%',
                transform: 'translateY(-50%)',
              }}
            >
              <ChevronRight fontSize="small" />
            </ScrollButton>

            <HorizontalScroller 
              ref={borderColorRef}
              onScroll={handleColorScroll}
              sx={{ 
                pt: 0, 
                mt: 0, 
                pb: 0, 
                pr: 2,
                minHeight: 50,
                gap: theme.spacing(1)
              }}
            >
              {/* Custom color picker - as first option, always using saved custom color */}
              <Tooltip title="Pick Custom Color" arrow>
                <Box sx={{ 
                  position: 'relative', 
                  display: 'flex', 
                  alignItems: 'center',
                  height: '60%' // Match the height of the color swatches
                }}>
                  <ColorSwatch
                    onClick={() => colorPickerRef.current && colorPickerRef.current.click()}
                    selected={false} // Never show this as selected
                    sx={{ 
                      position: 'relative',
                      // Always use the saved custom color from localStorage as background
                      backgroundColor: savedCustomColor,
                      // Add subtle checkerboard pattern for the color picker
                      backgroundImage: 'linear-gradient(45deg, rgba(200,200,200,0.2) 25%, transparent 25%), linear-gradient(-45deg, rgba(200,200,200,0.2) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, rgba(200,200,200,0.2) 75%), linear-gradient(-45deg, transparent 75%, rgba(200,200,200,0.2) 75%)',
                      backgroundSize: '8px 8px',
                      backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px',
                    }}
                  >
                    <Colorize fontSize="small" sx={{ color: isDarkColor(savedCustomColor) ? '#fff' : '#000' }} />
                  </ColorSwatch>
                  <input
                    type="color"
                    value={savedCustomColor}
                    onChange={handleCustomColorChange}
                    ref={colorPickerRef}
                    style={{ 
                      position: 'absolute',
                      opacity: 0,
                      width: '100%',
                      height: '100%',
                      cursor: 'pointer'
                    }}
                  />
                </Box>
              </Tooltip>
              
              {/* Show the saved custom color as second option if it exists and is different from presets */}
              {hasSavedCustomColor && (
                <Tooltip title="Custom Color" arrow>
                  <ColorSwatch
                    onClick={() => setBorderColor(savedCustomColor)}
                    selected={borderColor === savedCustomColor}
                    sx={{ backgroundColor: savedCustomColor }}
                  />
                </Tooltip>
              )}
              
              {/* Preset colors */}
              {COLOR_PRESETS.map((colorOption) => (
                <Tooltip key={colorOption.color} title={colorOption.name} arrow>
                  <ColorSwatch
                    onClick={() => setBorderColor(colorOption.color)}
                    selected={borderColor === colorOption.color}
                    sx={{ backgroundColor: colorOption.color }}
                  />
                </Tooltip>
              ))}
              
              {/* Spacer to ensure last items can be centered when scrolled fully */}
              <Box sx={{ minWidth: 4, flexShrink: 0 }} />
            </HorizontalScroller>
            
            {/* Visual indicators for scrolling */}
            <ScrollIndicator 
              direction="left" 
              isVisible={colorLeftScroll}
            />
            
            <ScrollIndicator 
              direction="right" 
              isVisible={colorRightScroll}
            />
          </Box>
        </Box>
      </Box>
    </Box>
  );
};

export default CollageLayoutSettings; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/UpgradeMessage.js ===

import React, { useRef } from 'react';
import { useTheme } from "@mui/material/styles";
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  Stack, 
  Button, 
  Container, 
  useMediaQuery,
  Chip
} from "@mui/material";
import { 
  Dashboard,
  Stars,
  LockOpen,
  CheckCircle
} from "@mui/icons-material";

/**
 * UpgradeMessage component displays a message prompting users to upgrade to Pro
 * to access premium features like the Collage Tool.
 * 
 * @param {Object} props - Component props
 * @param {Function} props.openSubscriptionDialog - Function to open the subscription dialog
 * @param {string} props.featureName - Name of the premium feature (default: "Collage Tool")
 * @param {string} props.previewImage - Path to preview image (default: "/assets/images/products/collage-tool.png")
 * @returns {JSX.Element} - The rendered component
 */
const UpgradeMessage = ({ 
  openSubscriptionDialog, 
  featureName = "Collage Tool",
  previewImage = "/assets/images/collage-tool.png"
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const isSmall = useMediaQuery(theme.breakpoints.down('md'));
  
  // Add ref for the PRO EARLY ACCESS card
  const proCardRef = useRef(null);
  
  // Function to scroll to the PRO EARLY ACCESS card
  const scrollToProCard = () => {
    if (proCardRef.current) {
      proCardRef.current.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }
  };
  
  // Approximate height of the app's top navigation bar
  const appBarHeight = 64; // in pixels

  return (
    <Box 
      sx={{ 
        position: 'fixed',
        top: `${appBarHeight}px`,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: 1000,
        background: theme.palette.mode === 'dark' 
          ? 'linear-gradient(135deg, rgba(25,25,35,1) 0%, rgba(15,15,25,1) 100%)' 
          : 'linear-gradient(135deg, #f8f8f8 0%, #eaeaea 100%)',
        display: 'flex',
        alignItems: 'flex-start',
        justifyContent: 'center',
        overflowY: 'auto',
        pt: { xs: 4, sm: 5 },
        pb: { xs: 10, sm: 8 }
      }}
    >
      <Container 
        maxWidth="lg" 
        sx={{ 
          pt: { xs: 3, sm: 5 },
          pb: { xs: 12, sm: 8 }
        }}
      >
        <Box textAlign="center" mb={isMobile ? 3 : 4}>
          <Typography 
            variant="h4" 
            component="h1" 
            sx={{ 
              display: 'flex', 
              alignItems: 'center',
              justifyContent: 'center',
              flexDirection: isMobile ? 'column' : 'row',
              fontWeight: '600',
              color: theme.palette.mode === 'dark' ? '#fff' : '#333',
              fontSize: isMobile ? '1.75rem' : '2.125rem',
              gap: isMobile ? 1 : 1.5
            }}
          >
            <Box sx={{
              display: 'flex',
              alignItems: 'center',
              gap: 1.5
            }}>
              <Dashboard sx={{ 
                color: theme.palette.primary.main,
                fontSize: isMobile ? '1.75rem' : '2.125rem'
              }} /> 
              <Box component="span">{featureName}</Box>
            </Box>
            <Chip 
              icon={<Stars sx={{ fontSize: '0.85rem' }} />}
              label="Early Access" 
              color="secondary" 
              size="small"
              sx={{ 
                height: 'auto',
                py: 0.5,
                alignSelf: 'center',
                fontWeight: 'bold',
                mt: isMobile ? 0.5 : 0,
                '& .MuiChip-icon': { 
                  color: 'inherit',
                  marginRight: '4px',
                  marginLeft: '4px'
                },
                '& .MuiChip-label': {
                  padding: '0 8px 0 4px'
                }
              }} 
            />
          </Typography>
        </Box>
        
        <Grid 
          container 
          spacing={isMobile ? 3 : 4} 
          justifyContent="center" 
          alignItems="center"
        >
          {/* Mobile layout: image on top, text below */}
          {isMobile && (
            <Grid item xs={12} sx={{ mb: 2 }}>
              <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                <Paper 
                  elevation={8} 
                  sx={{ 
                    p: 0,
                    borderRadius: 3,
                    maxWidth: 340,
                    width: '100%',
                    backgroundColor: 'rgba(0,0,0,0.75)',
                    border: `1px solid ${theme.palette.common.white}30`,
                    overflow: 'hidden',
                    boxShadow: `0 15px 30px rgba(0,0,0,0.5)`,
                    transform: 'perspective(1000px) rotateX(5deg) scale(0.9)',
                    transformOrigin: 'center top',
                    position: 'relative',
                    cursor: 'pointer',
                    '&::after': {
                      content: '""',
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      width: '100%',
                      height: '100%',
                      background: 'linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 20%)',
                      pointerEvents: 'none',
                      zIndex: 1
                    }
                  }}
                  onClick={scrollToProCard}
                >
                  <img 
                    src={previewImage} 
                    alt={`${featureName} Preview`} 
                    style={{ 
                      width: '100%', 
                      height: 'auto',
                      display: 'block',
                      objectFit: 'cover',
                    }}
                  />
                </Paper>
              </Box>
            </Grid>
          )}

          {/* Pro Message */}
          <Grid item xs={12} sm={isSmall ? 12 : 6} lg={5} sx={{ 
            display: 'flex', 
            justifyContent: 'center',
            order: { xs: 2, sm: isSmall ? 2 : 1 }
          }}>
            <Paper 
              ref={proCardRef}
              elevation={3} 
              sx={{ 
                p: isMobile ? 3 : 4, 
                borderRadius: 2, 
                textAlign: 'center',
                background: theme.palette.mode === 'dark' 
                  ? 'linear-gradient(145deg, rgba(35,35,45,1) 0%, rgba(25,25,35,1) 100%)' 
                  : 'linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%)',
                maxWidth: isSmall ? 500 : 450,
                width: '100%',
                border: `1px solid ${theme.palette.primary.main}20`,
                boxShadow: `0 10px 30px ${theme.palette.mode === 'dark' ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'}`
              }}
            >
              <Stack spacing={isMobile ? 2.5 : 3} justifyContent="center" alignItems="center">
                <Box sx={{ position: 'relative', display: 'flex', justifyContent: 'center' }}>
                  <img
                    src="/assets/memeSRC-white.svg"
                    alt="memeSRC logo"
                    style={{ height: 48 }}
                  />
                  <Box 
                    sx={{ 
                      position: 'absolute', 
                      top: -10, 
                      right: -10, 
                      bgcolor: theme.palette.secondary.main,
                      color: '#fff',
                      borderRadius: '50%',
                      width: 28,
                      height: 28,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    <LockOpen sx={{ fontSize: 16 }} />
                  </Box>
                </Box>
                
                <Box>
                  <Typography 
                    id="pro-upgrade-section" 
                    variant="h5" 
                    fontWeight="600" 
                    color="primary" 
                    gutterBottom
                  >
                    PRO EARLY ACCESS
                  </Typography>
                  
                  <Typography 
                    variant="body1" 
                    color="text.secondary"
                    sx={{ maxWidth: '360px', mx: 'auto' }}
                  >
                    Upgrade to unlock this feature today!
                  </Typography>
                </Box>
                
                <Box sx={{ width: '100%', display: 'flex', justifyContent: 'center' }}>
                  <Button
                    onClick={openSubscriptionDialog}
                    variant="contained"
                    size="large"
                    color="primary"
                    sx={{ 
                      fontSize: 16, 
                      width: isMobile ? '100%' : '80%',
                      py: 1.2,
                      borderRadius: 2,
                      fontWeight: 'bold',
                      boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                      mx: 'auto'
                    }}
                  >
                    Upgrade to Pro
                  </Button>
                </Box>

                <Box sx={{ 
                  width: '100%', 
                  pt: 1, 
                  display: 'flex', 
                  flexDirection: 'column', 
                  alignItems: 'flex-start',
                  px: isMobile ? 1 : 2
                }}>
                  <Typography 
                    variant="subtitle2" 
                    fontWeight="600" 
                    color="text.primary"
                    gutterBottom
                    sx={{ alignSelf: 'center', mb: 1.5 }}
                  >
                    What You'll Get:
                  </Typography>
                  
                  <Grid container spacing={1.5}>
                    {[
                      "Multi-panel layouts", 
                      "Custom aspect ratios", 
                      "One-click downloads",
                      "Early access to new features"
                    ].map((feature, index) => (
                      <Grid item xs={12} key={index}>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <CheckCircle 
                            color="success" 
                            sx={{ fontSize: 20, mr: 1.5 }} 
                          />
                          <Typography variant="body2" textAlign="left">
                            {feature}
                          </Typography>
                        </Box>
                      </Grid>
                    ))}
                  </Grid>
                </Box>
              </Stack>
            </Paper>
          </Grid>
          
          {/* Feature Preview Image - Tablet and Desktop */}
          <Grid item sm={isSmall ? 12 : 6} md={6} lg={6} sx={{ 
            display: { xs: 'none', sm: 'flex' }, 
            justifyContent: 'center',
            order: { xs: 1, sm: isSmall ? 1 : 2 },
            mb: isSmall ? 3 : 0
          }}>
            <Paper 
              elevation={8} 
              sx={{ 
                p: 0,
                borderRadius: 3,
                maxWidth: isSmall ? 420 : 480,
                width: '90%',
                backgroundColor: 'rgba(0,0,0,0.75)',
                border: `1px solid ${theme.palette.common.white}30`,
                overflow: 'hidden',
                boxShadow: `0 20px 40px ${theme.palette.mode === 'dark' ? 'rgba(0,0,0,0.6)' : 'rgba(0,0,0,0.25)'}`,
                transform: 'perspective(1200px) rotateX(5deg) rotateY(-2deg) scale(0.9)',
                transformOrigin: 'center center',
                transition: 'transform 0.3s ease',
                cursor: 'pointer',
                '&:hover': {
                  transform: 'perspective(1200px) rotateX(2deg) rotateY(-1deg) scale(0.92)',
                },
                position: 'relative',
                '&::after': {
                  content: '""',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  background: 'linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 20%)',
                  pointerEvents: 'none',
                  zIndex: 1
                }
              }}
              onClick={scrollToProCard}
            >
              <img 
                src={previewImage} 
                alt={`${featureName} Preview`} 
                style={{ 
                  width: '100%', 
                  height: 'auto',
                  display: 'block',
                  objectFit: 'cover',
                }}
              />
            </Paper>
          </Grid>
        </Grid>

        {/* Coming Soon Badge - Tablet and Desktop only */}
        {!isMobile && (
          <Box sx={{ 
            mt: 4, 
            display: 'flex', 
            justifyContent: 'center',
          }}>
            <Chip
              icon={<Dashboard sx={{ fontSize: '1rem !important' }} />}
              label="Coming soon for all users • Pro subscribers get early access"
              color="default"
              variant="outlined"
              sx={{ 
                py: 2.5,
                px: 1, 
                borderRadius: 3,
                fontSize: '0.9rem',
                fontWeight: 'medium',
                backdropFilter: 'blur(8px)',
                background: theme.palette.mode === 'dark' 
                  ? 'rgba(35,35,45,0.3)' 
                  : 'rgba(255,255,255,0.5)',
                borderColor: theme.palette.divider,
                '& .MuiChip-icon': { 
                  color: theme.palette.primary.main
                }
              }}
            />
          </Box>
        )}
      </Container>
    </Box>
  );
};

export default UpgradeMessage;

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/CollageUIComponents.js ===

import React from 'react';
import { useTheme } from "@mui/material/styles";
import {
  Box,
  Typography
} from "@mui/material";

/**
 * Header component for the collage page
 */
export const PageHeader = ({ icon: Icon, title, isMobile }) => {
  return (
    <Box>
      <Typography variant="h3" gutterBottom sx={{ 
        display: 'flex', 
        alignItems: 'center',
        fontWeight: '700', 
        mb: isMobile ? 0.75 : 1.5,
        pl: isMobile ? 1 : 0,
        color: '#fff',
        fontSize: isMobile ? '2.2rem' : '2.5rem',
        textShadow: '0px 2px 4px rgba(0,0,0,0.15)'
      }}>
        <Icon sx={{ mr: 2, color: 'inherit', fontSize: 40 }} /> {title}
      </Typography>
      <Typography variant="subtitle1" sx={{ 
        color: 'text.secondary',
        mb: isMobile ? 2 : 2.5,
        pl: isMobile ? 1 : 5,
        maxWidth: '85%'
      }}>
        Merge images together to create multi-panel memes
      </Typography>
    </Box>
  );
};

/**
 * Section heading with icon
 */
export const SectionHeading = ({ icon: Icon, title, sx = {} }) => {
  const theme = useTheme();
  
  return (
    <Box sx={{ 
      display: 'flex', 
      alignItems: 'center',
      mb: 1.25,
      paddingLeft: theme.spacing(0.5),
      paddingRight: theme.spacing(0.5),
      ...sx
    }}>
      <Icon sx={{ 
        mr: 1.5, 
        fontSize: '1.3rem' 
      }} />
      <Typography variant="h5" fontWeight={600}>
        {title}
      </Typography>
    </Box>
  );
}; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/CollageLayoutComponents.js ===

import React from 'react';
import { useTheme } from "@mui/material/styles";
import {
  Box,
  Grid,
  Typography,
  Container,
  Button
} from "@mui/material";
import { Settings, PhotoLibrary } from "@mui/icons-material";

import CollageSettingsStep from "../steps/CollageSettingsStep";
import CollageImagesStep from "../steps/CollageImagesStep";
import { SectionHeading } from './CollageUIComponents';

/**
 * Main container for the collage page content
 */
export const MainContainer = ({ children, isMobile, isMediumScreen }) => {
  return (
    <Box component="main" sx={{ 
      flexGrow: 1,
      pb: 6,
      width: '100%',
      overflowX: 'hidden'
    }}>
      <Container 
        maxWidth={isMediumScreen ? "xl" : "lg"} 
        sx={{ 
          pt: isMobile ? 2 : 3,
          px: isMobile ? 2 : 3,
          width: '100%'
        }}
        disableGutters={isMobile}
      >
        {children}
      </Container>
    </Box>
  );
};

/**
 * Paper container for the main content
 */
export const ContentPaper = ({ children, isMobile, sx = {} }) => {
  return (
    <Box sx={{ 
      width: '100%',
      ...sx
    }}>
      {children}
    </Box>
  );
};

/**
 * Unified layout for the collage tool that adapts to all screen sizes
 */
export const CollageLayout = ({ settingsStepProps, imagesStepProps, isMobile }) => {
  // Added console logging for debugging
  console.log("CollageLayout received props:", {
    settingsStepProps: {
      hasTemplate: !!settingsStepProps.selectedTemplate,
      hasAspectRatio: !!settingsStepProps.selectedAspectRatio,
      panelCount: settingsStepProps.panelCount,
      borderThickness: settingsStepProps.borderThickness
    },
    imagesStepProps: {
      hasTemplate: !!imagesStepProps.selectedTemplate,
      hasAspectRatio: !!imagesStepProps.selectedAspectRatio,
      imageCount: imagesStepProps.selectedImages.length,
      panelCount: imagesStepProps.panelCount
    }
  });
  
  return (
    <Grid container spacing={isMobile ? 2 : 3} sx={{ width: '100%', margin: 0 }}>
      {/* Settings Section */}
      <Grid item xs={12} md={6}>
        <CollageSettingsStep 
          {...settingsStepProps}
        />
      </Grid>
      
      {/* Images Section */}
      <Grid item xs={12} md={6}>
        <Box>
          <SectionHeading icon={PhotoLibrary} title="Images" />
          <CollageImagesStep {...imagesStepProps} />
        </Box>
      </Grid>
    </Grid>
  );
};

/**
 * Component for displaying the final collage result
 */
export const CollageResult = ({ finalImage, setFinalImage, isMobile, isMediumScreen, isLoading = false }) => {
  const theme = useTheme();
  
  return (
    <Box sx={{ 
      mt: 3,
      width: '100%',
      backgroundColor: theme.palette.common.black,
      borderRadius: 2,
      border: '1px solid rgba(255, 255, 255, 0.2)',
      overflow: 'hidden',
      boxShadow: '0 4px 20px rgba(0,0,0,0.2)'
    }}>
      {/* Image container - No extra wrappers */}
      <img 
        src={finalImage} 
        alt="Final Collage" 
        style={{ 
          width: '100%', 
          display: 'block',
          opacity: isLoading ? 0.7 : 1
        }} 
      />
      
      {/* Button container - Only "Create New" option */}
      <Box sx={{ 
        display: 'flex', 
        justifyContent: 'center',
        gap: 2,
        p: 2,
        borderTop: '1px solid rgba(255, 255, 255, 0.15)',
        backgroundColor: 'rgba(0, 0, 0, 0.8)'
      }}>
        <Button 
          variant="outlined" 
          color="primary" 
          onClick={() => setFinalImage(null)}
          disabled={isLoading}
        >
          Create New Collage
        </Button>
      </Box>
    </Box>
  );
}; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/utils/CanvasLayoutRenderer.js ===

import { aspectRatioPresets, getLayoutsForPanelCount } from "../config/CollageConfig";
import { getAspectRatioCategory } from "../config/layouts/LayoutUtils";

// Debug flag - set to false in production
const DEBUG_MODE = false;

// Helper debug logger function that only logs when DEBUG_MODE is true
const debugLog = (...args) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Helper for warnings that should still show in production
const debugWarn = (...args) => {
  if (DEBUG_MODE) {
    console.warn(...args);
  } else if (args[0] && args[0].includes('critical')) {
    // Allow critical warnings to show even in production
    console.warn(...args);
  }
};

// Helper for errors that should always show
const logError = (...args) => {
  console.error(...args);
};

/**
 * Get the aspect ratio value from the presets
 * @param {string} selectedAspectRatio - The ID of the selected aspect ratio
 * @returns {number} The aspect ratio value
 */
export const getAspectRatioValue = (selectedAspectRatio) => {
  const aspectRatioPreset = aspectRatioPresets.find(preset => preset.id === selectedAspectRatio);
  return aspectRatioPreset ? aspectRatioPreset.value : 1; // Default to 1 (square) if not found
};

/**
 * Calculate canvas dimensions based on the selected aspect ratio
 * @param {string} selectedAspectRatio - The ID of the selected aspect ratio
 * @returns {Object} The width and height of the canvas
 */
export const calculateCanvasDimensions = (selectedAspectRatio) => {
  const aspectRatio = getAspectRatioValue(selectedAspectRatio);
  const maxSize = 1500; // Max size for longest dimension
  
  let width;
  let height;
  
  if (aspectRatio >= 1) {
    // Landscape or square
    width = maxSize;
    height = maxSize / aspectRatio;
  } else {
    // Portrait
    height = maxSize;
    width = maxSize * aspectRatio;
  }
  
  return { width: Math.round(width), height: Math.round(height) };
};

/**
 * Helper function to parse grid template strings like "1fr 2fr" into [1, 2]
 * @param {string} template - The grid template string
 * @returns {Array} Array of parsed values
 */
const parseGridTemplate = (template) => {
  if (!template) return [1];
  
  // Handle "repeat(N, 1fr)" format
  const repeatMatch = template.match(/repeat\((\d+),\s*([^)]+)\)/);
  if (repeatMatch) {
    const count = parseInt(repeatMatch[1], 10);
    const value = parseValue(repeatMatch[2].trim());
    return Array(count).fill(value);
  }
  
  // Handle "1fr 2fr" format
  return template.split(' ').map(parseValue);
};

/**
 * Helper to parse values like "1fr" into 1
 * @param {string} value - The value to parse
 * @returns {number} The parsed value
 */
const parseValue = (value) => {
  const frMatch = value.match(/(\d+)fr/);
  if (frMatch) {
    return parseInt(frMatch[1], 10);
  }
  return 1; // Default to 1 for unsupported formats
};

/**
 * Helper function to create a default grid layout when getLayoutConfig is missing
 * @param {number} count - The panel count
 * @param {string} selectedAspectRatio - The ID of the selected aspect ratio
 * @returns {Object} The layout configuration
 */
const createDefaultGridLayout = (count, selectedAspectRatio) => {
  // Determine grid dimensions based on panel count
  let columns;
  let rows;
  
  switch(count) {
    case 1:
      columns = 1; rows = 1;
      break;
    case 2:
      columns = 2; rows = 1;
      break;
    case 3:
      columns = 3; rows = 1;
      break;
    case 4:
      columns = 2; rows = 2;
      break;
    case 5:
      if (getAspectRatioValue(selectedAspectRatio) >= 1) { // Landscape or square
        columns = Math.ceil(count/2); rows = 2;
      } else { // Portrait
        columns = 2; rows = Math.ceil(count/2);
      }
      break;
    default:
      // Generic grid for any other counts
      columns = Math.ceil(Math.sqrt(count));
      rows = Math.ceil(count / columns);
      break;
  }
  
  return {
    gridTemplateColumns: `repeat(${columns}, 1fr)`,
    gridTemplateRows: `repeat(${rows}, 1fr)`,
    gridTemplateAreas: null,
    items: Array(count).fill({ gridArea: null })
  };
};

/**
 * Create layout configuration based on template ID
 * @param {string} templateId - The ID of the template
 * @param {number} count - The panel count
 * @returns {Object} The layout configuration
 */
const createLayoutConfigFromId = (templateId, count) => {
  // Two panel layouts
  if (count === 2) {
    switch(templateId) {
      case 'split-horizontal':
        return {
          gridTemplateColumns: '1fr 1fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'split-vertical':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '1fr 1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'two-thirds-one-third-h':
      case 'wide-left-narrow-right':
        return {
          gridTemplateColumns: '2fr 1fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'one-third-two-thirds-h':
      case 'narrow-left-wide-right':
        return {
          gridTemplateColumns: '1fr 2fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'two-thirds-one-third-v':
      case 'wide-top-narrow-bottom':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'one-third-two-thirds-v':
      case 'wide-bottom-narrow-top':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '1fr 2fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'wide-75-25-split':
        return {
          gridTemplateColumns: '3fr 1fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'tall-75-25-split':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '3fr 1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'top-tall-bottom-short':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'top-short-bottom-tall':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '1fr 2fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'left-wide-right-narrow':
        return {
          gridTemplateColumns: '2fr 1fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      case 'left-narrow-right-wide':
        return {
          gridTemplateColumns: '1fr 2fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(2).fill({ gridArea: null })
        };
      default:
        break;
    }
  }
  
  // Three panel layouts
  if (count === 3) {
    switch(templateId) {
      case 'main-with-two-bottom':
        return {
          gridTemplateColumns: '1fr 1fr',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: '"main main" "left right"',
          areas: ['main', 'left', 'right']
        };
      case '3-columns':
        return {
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(3).fill({ gridArea: null })
        };
      case '3-rows':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: null,
          items: Array(3).fill({ gridArea: null })
        };
      case 'center-feature-wide':
        return {
          gridTemplateColumns: '1fr 2fr 1fr',
          gridTemplateRows: '1fr',
          gridTemplateAreas: '"left main right"',
          areas: ['left', 'main', 'right']
        };
      case 'side-stack-wide':
      case 'main-with-two-right':
        return {
          gridTemplateColumns: '2fr 1fr',
          gridTemplateRows: '1fr 1fr',
          gridTemplateAreas: '"main top" "main bottom"',
          areas: ['main', 'top', 'bottom']
        };
      case 'center-feature-tall':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: '1fr 2fr 1fr',
          gridTemplateAreas: '"top" "main" "bottom"',
          areas: ['top', 'main', 'bottom']
        };
      case 'two-and-one-tall':
        return {
          gridTemplateColumns: '1fr 1fr',
          gridTemplateRows: '1fr 1fr',
          gridTemplateAreas: '"left right" "bottom bottom"',
          areas: ['left', 'right', 'bottom']
        };
      default:
        break;
    }
  }
  
  // Four panel layouts
  if (count === 4) {
    switch(templateId) {
      case 'grid-2x2':
        return {
          gridTemplateColumns: 'repeat(2, 1fr)',
          gridTemplateRows: 'repeat(2, 1fr)',
          gridTemplateAreas: null,
          items: Array(4).fill({ gridArea: null })
        };
      case 'big-and-3-bottom':
        return {
          gridTemplateColumns: '1fr 1fr 1fr',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: '"main main main" "left middle right"',
          areas: ['main', 'left', 'middle', 'right']
        };
      case 'big-and-3-right':
        return {
          gridTemplateColumns: '2fr 1fr',
          gridTemplateRows: '1fr 1fr 1fr',
          gridTemplateAreas: '"main top" "main middle" "main bottom"',
          areas: ['main', 'top', 'middle', 'bottom']
        };
      case '4-columns':
        return {
          gridTemplateColumns: 'repeat(4, 1fr)',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(4).fill({ gridArea: null })
        };
      case '4-rows':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: 'repeat(4, 1fr)',
          gridTemplateAreas: null,
          items: Array(4).fill({ gridArea: null })
        };
      case 'left-feature-with-3-right':
        return {
          gridTemplateColumns: '2fr 1fr',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: '"main top" "main middle" "main bottom"',
          areas: ['main', 'top', 'middle', 'bottom']
        };
      case 'right-feature-with-3-left':
        return {
          gridTemplateColumns: '1fr 2fr',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: '"top main" "middle main" "bottom main"',
          areas: ['top', 'middle', 'bottom', 'main']
        };
      case 'top-feature-with-3-bottom':
        return {
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: '"main main main" "left middle right"',
          areas: ['main', 'left', 'middle', 'right']
        };
      case 'bottom-feature-with-3-top':
        return {
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: '1fr 2fr',
          gridTemplateAreas: '"left middle right" "main main main"',
          areas: ['left', 'middle', 'right', 'main']
        };
      case 'split-bottom-feature-tall':
        return {
          gridTemplateColumns: '1fr 1fr',
          gridTemplateRows: '1fr 1fr 2fr',
          gridTemplateAreas: '"top-left top-right" "bottom-left bottom-right" "bottom bottom"',
          areas: ['top-left', 'top-right', 'bottom-left', 'bottom-right']
        };
      default:
        break;
    }
  }
  
  // Five panel layouts
  if (count === 5) {
    switch(templateId) {
      case 'featured-top-with-4-below':
        return {
          gridTemplateColumns: 'repeat(4, 1fr)',
          gridTemplateRows: '2fr 1fr',
          gridTemplateAreas: '"main main main main" "one two three four"',
          areas: ['main', 'one', 'two', 'three', 'four']
        };
      case 'featured-left-with-4-right':
      case 'featured-left-with-grid':
        return {
          gridTemplateColumns: '2fr 1fr 1fr',
          gridTemplateRows: 'repeat(2, 1fr)',
          gridTemplateAreas: '"main top-left top-right" "main bottom-left bottom-right"',
          areas: ['main', 'top-left', 'top-right', 'bottom-left', 'bottom-right']
        };
      case 'featured-center-with-4-corners':
        return {
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: '"top-left . top-right" ". main ." "bottom-left . bottom-right"',
          areas: ['top-left', 'top-right', 'main', 'bottom-left', 'bottom-right']
        };
      case '5-columns':
        return {
          gridTemplateColumns: 'repeat(5, 1fr)',
          gridTemplateRows: '1fr',
          gridTemplateAreas: null,
          items: Array(5).fill({ gridArea: null })
        };
      case '5-rows':
        return {
          gridTemplateColumns: '1fr',
          gridTemplateRows: 'repeat(5, 1fr)',
          gridTemplateAreas: null,
          items: Array(5).fill({ gridArea: null })
        };
      case 'asymmetric-5':
        return {
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: 'repeat(2, 1fr)',
          gridTemplateAreas: '"top-left top-middle top-right" "bottom-left bottom-left bottom-right"',
          areas: ['top-left', 'top-middle', 'top-right', 'bottom-left', 'bottom-right']
        };
      case 'split-5-panels':
        return {
          gridTemplateColumns: 'repeat(2, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: '"top-left top-right" "middle-left middle-right" "bottom bottom"',
          areas: ['top-left', 'top-right', 'middle-left', 'middle-right', 'bottom']
        };
      case 'vertical-asymmetric-5':
        return {
          gridTemplateColumns: 'repeat(2, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: '"top-left top-right" "middle middle" "bottom-left bottom-right"',
          areas: ['top-left', 'top-right', 'middle', 'bottom-left', 'bottom-right']
        };
      case 'tall-mosaic':
        return {
          gridTemplateColumns: 'repeat(2, 1fr)',
          gridTemplateRows: 'repeat(4, 1fr)',
          gridTemplateAreas: 
            '"top top" ' +
            '"middle-left middle-right" ' +
            '"middle-left middle-right" ' +
            '"bottom-left bottom-right"',
          areas: ['top', 'middle-left', 'middle-right', 'bottom-left', 'bottom-right']
        };
      case 'wide-mosaic':
        return {
          gridTemplateColumns: 'repeat(4, 1fr)',
          gridTemplateRows: 'repeat(3, 1fr)',
          gridTemplateAreas: 
            '"left-top left-top right-top right-top" ' +
            '"left-middle left-middle right-top right-top" ' +
            '"left-bottom right-bottom right-bottom right-bottom"',
          areas: ['left-top', 'left-middle', 'left-bottom', 'right-top', 'right-bottom']
        };
      case 'featured-bottom-with-4-top':
        return {
          gridTemplateColumns: 'repeat(4, 1fr)',
          gridTemplateRows: '1fr 2fr',
          gridTemplateAreas: '"one two three four" "main main main main"',
          areas: ['one', 'two', 'three', 'four', 'main']
        };
      default:
        break;
    }
  }
  
  // Fall back to default grid layout if no specific layout found
  debugWarn(`Template ID '${templateId}' not found in direct mapping, using default grid layout. This ID should be added to createLayoutConfigFromId function.`);
  return createDefaultGridLayout(count);
};

/**
 * Draw an upload icon in the center of an empty panel
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} panel - Panel region
 * @param {string} color - Color of the icon (used only for the plus sign)
 */
const drawUploadIcon = (ctx, panel, color = '#FFFFFF') => {
  const { x, y, width, height, consistentIconSize } = panel;
  const centerX = x + width / 2;
  const centerY = y + height / 2;
  
  // Save the current state
  ctx.save();
  
  // Use the consistent icon size if provided, otherwise calculate it based on the panel
  let iconSize;
  
  if (consistentIconSize !== undefined) {
    iconSize = consistentIconSize;
  } else {
    // Size the icon proportionally to the panel, but cap the maximum size
    // to 8% of the largest panel dimension (reduced from 10%)
    const maxSize = Math.max(width, height) * 0.08;
    const calculatedSize = Math.min(width, height) * 0.15; // Reduced from 0.18
    iconSize = Math.min(calculatedSize, maxSize);
  }
  
  // Draw a solid blue circle
  ctx.fillStyle = '#3b82f6'; // Bright blue color
  ctx.beginPath();
  ctx.arc(centerX, centerY, iconSize, 0, Math.PI * 2);
  ctx.fill();
  
  // Add white border around the circle
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = Math.max(2, iconSize * 0.08); // Proportional white border
  ctx.beginPath();
  ctx.arc(centerX, centerY, iconSize, 0, Math.PI * 2);
  ctx.stroke();
  
  // Set style for the plus sign
  ctx.strokeStyle = '#FFFFFF'; // Always white plus sign for good contrast
  
  // Draw a heavy plus sign (smaller than before)
  const plusSize = iconSize * 0.45; // Smaller plus (was 0.6)
  const lineWidth = Math.max(2, iconSize * 0.12); // Thicker line for better visibility
  
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round'; // Rounded ends for better appearance
  
  // Horizontal line of plus
  ctx.beginPath();
  ctx.moveTo(centerX - plusSize, centerY);
  ctx.lineTo(centerX + plusSize, centerY);
  ctx.stroke();
  
  // Vertical line of plus
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - plusSize);
  ctx.lineTo(centerX, centerY + plusSize);
  ctx.stroke();
  
  // Restore the canvas state
  ctx.restore();
};

/**
 * Finds the dimensions of the smallest panel in the layout
 * @param {Array} panelRegions - Array of panel region objects
 * @returns {Object} - Object containing the minimum width and height
 */
const findSmallestPanelDimensions = (panelRegions) => {
  if (!panelRegions || panelRegions.length === 0) {
    return { minWidth: 100, minHeight: 100 }; // Default fallback
  }
  
  // Find the smallest panel dimensions
  let minWidth = Infinity;
  let minHeight = Infinity;
  
  panelRegions.forEach(panel => {
    if (panel.width < minWidth) minWidth = panel.width;
    if (panel.height < minHeight) minHeight = panel.height;
  });
  
  return { minWidth, minHeight };
};

/**
 * Render the template to a canvas (either offscreen or regular)
 * @param {Object} params - The parameters
 * @param {Object} params.selectedTemplate - The selected template
 * @param {string} params.selectedAspectRatio - The ID of the selected aspect ratio
 * @param {number} params.panelCount - The panel count
 * @param {Object} params.theme - The theme object
 * @param {React.RefObject} params.canvasRef - The canvas reference
 * @param {function} params.setPanelRegions - Function to set panel regions
 * @param {function} params.setRenderedImage - Function to set rendered image
 * @param {number} params.borderThickness - The border thickness
 * @param {string} params.borderColor - The border color
 * @param {Array} params.selectedImages - Array of selected images
 * @param {Object} params.panelImageMapping - Object mapping panels to images
 */
export const renderTemplateToCanvas = ({
  selectedTemplate,
  selectedAspectRatio,
  panelCount,
  theme,
  canvasRef,
  setPanelRegions,
  setRenderedImage,
  borderThickness = 4,
  borderColor = '#FFFFFF', // Add default border color
  selectedImages = [],
  panelImageMapping = {}
}) => {
  console.log(`[RENDERER DEBUG] renderTemplateToCanvas received borderThickness: ${borderThickness}, panelCount: ${panelCount}, borderColor: ${borderColor}`);
  debugLog("renderTemplateToCanvas called with border thickness:", borderThickness);
  debugLog("renderTemplateToCanvas called with border color:", borderColor);
  debugLog("Panel image mapping:", panelImageMapping);
  
  // Check if we have a valid template
  if (!selectedTemplate) {
    logError('No template selected for rendering');
    return;
  }
  
  const { width, height } = calculateCanvasDimensions(selectedAspectRatio);
  
  let canvas;
  let ctx;
  
  // SIMPLIFIED: Prefer using regular canvas directly when available
  if (canvasRef && canvasRef.current) {
    canvas = canvasRef.current;
    canvas.width = width;
    canvas.height = height;
    ctx = canvas.getContext('2d');
  } else {
    // Only use OffscreenCanvas as fallback
    try {
      canvas = new OffscreenCanvas(width, height);
      ctx = canvas.getContext('2d');
    } catch (error) {
      logError("No canvas available for rendering");
      return;
    }
  }
  
  // Clear the canvas with a dark or light background based on theme
  ctx.fillStyle = theme.palette.mode === 'dark' ? '#121212' : '#f5f5f5';
  ctx.fillRect(0, 0, width, height);
  
  // Get layout configuration based on the template
  let layoutConfig;
  
  try {
    // Use simple approach to get layout config
    if (selectedTemplate.getLayoutConfig && typeof selectedTemplate.getLayoutConfig === 'function') {
      layoutConfig = selectedTemplate.getLayoutConfig();
    } else if (selectedTemplate.id) {
      layoutConfig = createLayoutConfigFromId(selectedTemplate.id, panelCount);
    } else {
      layoutConfig = createDefaultGridLayout(panelCount, selectedAspectRatio);
    }
  } catch (error) {
    logError('Error determining layout configuration:', error);
    // Create a simple default layout as fallback
    layoutConfig = createDefaultGridLayout(panelCount, selectedAspectRatio);
  }
  
  if (!layoutConfig) {
    logError('No layout configuration found for the selected template');
    // Use default grid as absolute fallback
    layoutConfig = createDefaultGridLayout(panelCount, selectedAspectRatio);
  }
  
  try {
    // Draw the layout panels
    const newPanelRegions = [];
    
    // Simplified: Parse grid templates directly for layout
    const columns = parseGridTemplate(layoutConfig.gridTemplateColumns);
    const rows = parseGridTemplate(layoutConfig.gridTemplateRows);
    
    // Calculate cell dimensions
    const totalColumnFr = columns.reduce((sum, val) => sum + val, 0);
    const totalRowFr = rows.reduce((sum, val) => sum + val, 0);
    
    const cellWidths = columns.map(fr => (fr / totalColumnFr) * width);
    const cellHeights = rows.map(fr => (fr / totalRowFr) * height);
    
    // Save the border settings for later
    const shouldDrawBorder = borderThickness > 0;
    ctx.fillStyle = '#808080'; // Grey placeholder for panels
    
    // Calculate grid positions
    const rowPositions = [];
    let currentY = 0;
    rows.forEach((_, index) => {
      rowPositions[index] = currentY;
      currentY += cellHeights[index];
    });
    
    const colPositions = [];
    let currentX = 0;
    columns.forEach((_, index) => {
      colPositions[index] = currentX;
      currentX += cellWidths[index];
    });
    
    // Create panel regions based on the layout configuration
    let panelIndex = 0;
    
    // Check if we have grid template areas defined for complex layouts
    if (layoutConfig.gridTemplateAreas && layoutConfig.areas && layoutConfig.areas.length > 0) {
      debugLog("Using grid template areas for complex layout", layoutConfig.gridTemplateAreas);
      
      // Parse the grid template areas - handle different string formats
      let gridAreasMatrix = [];
      const areasString = layoutConfig.gridTemplateAreas.trim();
      
      // Reset matrix for fresh parsing
      console.log("Original grid template areas string:", areasString);
      
      // Enhanced parsing of grid template areas with better format handling
      try {
        // Fix the parsing of grid template areas formatted as quoted strings
        if (areasString.includes('"')) {
          // Extract each quoted group using regex to properly split multi-row templates
          const matches = areasString.match(/"([^"]+)"/g) || [];
          
          if (matches.length > 0) {
            gridAreasMatrix = matches.map(quotedRow => {
              // Remove quotes and split by whitespace
              return quotedRow
                .replace(/"/g, '')
                .trim()
                .split(/\s+/)
                .filter(Boolean);
            });
            
            console.log("Parsed grid areas matrix from quotes:", gridAreasMatrix);
          } else {
            // Fallback if regex failed
            gridAreasMatrix = [areasString.replace(/"/g, '').trim().split(/\s+/).filter(Boolean)];
          }
        } else if (areasString.includes('\n')) {
          // Format with newlines only
          gridAreasMatrix = areasString
            .split('\n')
            .map(row => row.trim().split(/\s+/).filter(Boolean))
            .filter(row => row.length > 0);
        } else {
          // Single line format without quotes
          gridAreasMatrix = [areasString.trim().split(/\s+/).filter(Boolean)];
        }
        
        // Add validation to ensure we have a valid matrix
        if (gridAreasMatrix.length === 0 || gridAreasMatrix.some(row => row.length === 0)) {
          console.warn('Empty grid areas matrix after parsing, falling back to simple format');
          // Fallback to simplest parsing
          gridAreasMatrix = [areasString.replace(/"/g, '').trim().split(/\s+/)];
        }
      } catch (error) {
        console.error('Error parsing grid template areas:', error);
        // Fallback to simpler parsing as a last resort
        gridAreasMatrix = [areasString.replace(/["\n]/g, ' ').trim().split(/\s+/).filter(Boolean)];
      }
      
      console.log("Grid areas matrix after parsing:", JSON.stringify(gridAreasMatrix));
      
      // Validate that the grid areas matrix has the expected structure
      const rowCount = gridAreasMatrix.length;
      const colCount = Math.max(...gridAreasMatrix.map(row => row.length));
      
      console.log(`Grid dimensions: ${rowCount} rows × ${colCount} columns`);
      
      // Create a map of area name to panel region
      const areaToRegionMap = {};
      const allAreas = new Set(); // Track all unique areas found in the matrix

      // First pass: determine the boundaries of each named area
      gridAreasMatrix.forEach((row, rowIndex) => {
        row.forEach((areaName, colIndex) => {
          if (areaName !== '.' && areaName !== '') { // Skip empty cells
            allAreas.add(areaName); // Add to set of all areas
            
            if (!areaToRegionMap[areaName]) {
              areaToRegionMap[areaName] = {
                minRow: rowIndex,
                maxRow: rowIndex,
                minCol: colIndex,
                maxCol: colIndex
              };
            } else {
              // Update boundaries for this area
              areaToRegionMap[areaName].minRow = Math.min(areaToRegionMap[areaName].minRow, rowIndex);
              areaToRegionMap[areaName].maxRow = Math.max(areaToRegionMap[areaName].maxRow, rowIndex);
              areaToRegionMap[areaName].minCol = Math.min(areaToRegionMap[areaName].minCol, colIndex);
              areaToRegionMap[areaName].maxCol = Math.max(areaToRegionMap[areaName].maxCol, colIndex);
            }
          }
        });
      });
      
      debugLog("Area to region map:", areaToRegionMap);
      debugLog("All areas found in matrix:", [...allAreas]);

      // Check if we have areas in the grid template that aren't in the areas array
      // This might indicate a mismatch in the template definition
      const missingAreas = [];
      allAreas.forEach(area => {
        if (!layoutConfig.areas.includes(area)) {
          missingAreas.push(area);
        }
      });
      
      if (missingAreas.length > 0) {
        debugWarn(`Found areas in grid template that aren't in the areas array: ${missingAreas.join(', ')}`);
        // If we have extra areas in the template, add them to the areas array to ensure we create all needed panels
        // Only do this if the total doesn't exceed panelCount
        if (layoutConfig.areas.length + missingAreas.length <= panelCount) {
          debugLog(`Adding missing areas to the areas array: ${missingAreas.join(', ')}`);
          layoutConfig.areas = [...layoutConfig.areas, ...missingAreas];
        }
      }
      
      // Create a special fallback order if needed - use all areas from the matrix
      // in case the areas array is missing or incomplete
      const fallbackOrder = [...allAreas];
      
      // Second pass: create panel regions using either template areas or fallback
      // Important: Process areas in the same order they're specified in the template's areas array
      // This ensures image mappings work correctly
      const createdPanels = new Set();
      
      // Use areas specified in the template, or fall back to all areas found in the matrix
      const areasToProcess = layoutConfig.areas.length > 0 ? layoutConfig.areas : fallbackOrder;
      
      areasToProcess.forEach((areaName, index) => {
        if (index >= panelCount) return; // Don't create more panels than needed
        
        const region = areaToRegionMap[areaName];
        if (!region) {
          debugWarn(`Area '${areaName}' not found in grid template areas`);
          return;
        }
        
        try {
          // Calculate the panel's dimensions and position
          const x = colPositions[region.minCol];
          const y = rowPositions[region.minRow];
          
          // Debug the positions and ranges for this panel
          console.log(`Panel '${areaName}' grid position:`, {
            rowRange: [region.minRow, region.maxRow],
            colRange: [region.minCol, region.maxCol],
            rowPos: rowPositions.slice(region.minRow, region.maxRow + 1),
            colPos: colPositions.slice(region.minCol, region.maxCol + 1),
            cellWidths: cellWidths.slice(region.minCol, region.maxCol + 1),
            cellHeights: cellHeights.slice(region.minRow, region.maxRow + 1)
          });
          
          // If any positions or dimensions are missing, use safe fallbacks
          const fallbackX = typeof colPositions[0] === 'number' ? colPositions[0] : 0;
          const fallbackY = typeof rowPositions[0] === 'number' ? rowPositions[0] : 0;
          const fixedX = typeof x === 'number' ? x : fallbackX;
          const fixedY = typeof y === 'number' ? y : fallbackY;
          
          // Log a warning if we had to use fallbacks
          if (x === undefined || y === undefined) {
            console.warn(`Position undefined for panel '${areaName}', using fallback position x=${fixedX}, y=${fixedY}`);
          }
          
          // Calculate width differently - first ensure we have valid column positions
          let panelWidth = 0;
          if (region.minCol < colPositions.length && region.maxCol < colPositions.length) {
            if (region.maxCol > region.minCol) {
              // Start with the position difference
              panelWidth = colPositions[region.maxCol] - colPositions[region.minCol];
              // Add the width of the last cell
              panelWidth += cellWidths[region.maxCol];
            } else {
              // Just use the width of a single cell
              panelWidth = cellWidths[region.minCol];
            }
          } else {
            // Fallback: use a percentage of the total width
            panelWidth = width / colCount;
          }
          
          // Calculate height similarly
          let panelHeight = 0;
          if (region.minRow < rowPositions.length && region.maxRow < rowPositions.length) {
            if (region.maxRow > region.minRow) {
              // Start with the position difference
              panelHeight = rowPositions[region.maxRow] - rowPositions[region.minRow];
              // Add the height of the last cell
              panelHeight += cellHeights[region.maxRow];
            } else {
              // Just use the height of a single cell
              panelHeight = cellHeights[region.minRow];
            }
          } else {
            // Fallback: use a percentage of the total height
            panelHeight = height / rowCount;
          }
          
          // Ensure the panel has valid dimensions
          if (!Number.isFinite(fixedX) || !Number.isFinite(fixedY) || !Number.isFinite(panelWidth) || !Number.isFinite(panelHeight) || 
              panelWidth <= 0 || panelHeight <= 0) {
            debugWarn(`Invalid panel dimensions for area '${areaName}':`, 
              { x: fixedX, y: fixedY, width: panelWidth, height: panelHeight });
            return;
          }
          
          // Draw panel placeholder - Make sure to use grey color for all panels
          ctx.fillStyle = '#808080'; // Ensure consistent grey color for placeholders
          ctx.fillRect(fixedX, fixedY, panelWidth, panelHeight);
          
          // Use consistent panel IDs based on index in the areas array
          // This ensures that panel IDs match what the template and UI expect
          const panelId = index;
          
          // Store panel region
          newPanelRegions.push({
            id: panelId,
            name: areaName,
            x: fixedX,
            y: fixedY,
            width: panelWidth,
            height: panelHeight
          });
          
          createdPanels.add(areaName);
          panelIndex = Math.max(panelIndex, index + 1);
        } catch (error) {
          console.error(`Error creating panel for area '${areaName}':`, error);
        }
      });
      
      // Diagnostic information
      debugLog(`Created ${newPanelRegions.length} panels out of expected ${panelCount}`);
      if (newPanelRegions.length < panelCount) {
        debugWarn(`Missing ${panelCount - newPanelRegions.length} panels in the layout`);
      }
      
      // Log warning if areas defined in the matrix weren't used
      Object.keys(areaToRegionMap).forEach(areaName => {
        if (!createdPanels.has(areaName) && areaName !== '.') {
          debugWarn(`Area '${areaName}' defined in grid template but not used in panel creation`);
        }
      });
    } else {
      // Use simple grid layout for templates without grid areas
      debugLog("Using simple grid layout with columns and rows");
      
      // Step 1: Draw all panels without borders first
      for (let row = 0; row < rows.length && panelIndex < panelCount; row += 1) {
        for (let col = 0; col < columns.length && panelIndex < panelCount; col += 1) {
          try {
            const x = colPositions[col];
            const y = rowPositions[row];
            const width = cellWidths[col];
            const height = cellHeights[row];
            
            // Ensure the panel has valid dimensions
            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height) || 
                width <= 0 || height <= 0) {
              debugWarn(`Invalid panel dimensions at grid position [${row}][${col}]:`, 
                { x, y, width, height });
              return;
            }
            
            // Draw panel placeholder with consistent color
            ctx.fillStyle = '#808080'; // Ensure consistent grey color for placeholders
            ctx.fillRect(x, y, width, height);
            
            // Store panel region
            const panel = {
              id: panelIndex,
              name: `panel-${panelIndex}`,
              x,
              y,
              width,
              height
            };
            
            newPanelRegions.push(panel);
            
            panelIndex += 1;
          } catch (error) {
            console.error(`Error creating panel at grid position [${row}][${col}]:`, error);
          }
        }
      }
    }
    
    // Find the smallest panel dimensions after all panels are created
    const { minWidth, minHeight } = findSmallestPanelDimensions(newPanelRegions);
    
    // Draw upload icons after determining consistent size based on smallest panel
    newPanelRegions.forEach(panel => {
      // Check if this panel has an image assigned
      const hasImage = panelImageMapping && 
                       Object.prototype.hasOwnProperty.call(panelImageMapping, panel.id) && 
                       typeof panelImageMapping[panel.id] === 'number';
      
      // Draw upload icon if panel is empty
      if (!hasImage) {
        // Use either white or dark gray based on theme to ensure visibility
        const iconColor = theme.palette.mode === 'dark' ? '#FFFFFF' : '#555555';
        
        // Calculate consistent icon size based on the smallest panel dimensions
        const maxConsistentSize = Math.max(minWidth, minHeight) * 0.08;
        const calculatedConsistentSize = Math.min(minWidth, minHeight) * 0.15;
        const consistentIconSize = Math.min(calculatedConsistentSize, maxConsistentSize);
        
        // Keep original panel position but use consistent size
        drawUploadIcon(ctx, {
          x: panel.x, 
          y: panel.y,
          width: panel.width,
          height: panel.height,
          consistentIconSize
        }, iconColor);
      }
    });
    
    // Set styles for the border - we'll only draw borders once after all images are loaded
    if (shouldDrawBorder) {
      console.log(`[RENDERER DEBUG] Setting border properties: color=${borderColor}, thickness=${borderThickness}`);
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = borderThickness;
    }
    
    // Generate initial canvas image without waiting for images to load
    if (canvas instanceof OffscreenCanvas) {
      canvas.convertToBlob({ type: 'image/png' })
        .then(blob => {
          const url = URL.createObjectURL(blob);
          setRenderedImage(url);
        })
        .catch(err => {
          logError('Error converting canvas to blob:', err);
          if (canvasRef && canvasRef.current) {
            setRenderedImage(canvasRef.current.toDataURL('image/png'));
          }
        });
    } else {
      try {
        setRenderedImage(canvas.toDataURL('image/png'));
      } catch (err) {
        logError('Error converting canvas to data URL:', err);
      }
    }
    
    // Step 3: Now load and draw images
    const imageLoadPromises = [];
    
    newPanelRegions.forEach(panel => {
      const panelId = panel.id;
      const imageIndex = panelImageMapping[panelId];
      
      if (typeof imageIndex === 'number' && 
          imageIndex >= 0 && 
          imageIndex < selectedImages.length) {
        
        // Get image URL
        const imageItem = selectedImages[imageIndex];
        const imageUrl = typeof imageItem === 'object' && imageItem !== null 
          ? (imageItem.url || imageItem.imageUrl || imageItem) 
          : imageItem;
          
        // Load the image
        const imgPromise = new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            // Calculate scaling to fit panel
            const imgAspect = img.width / img.height;
            const panelAspect = panel.width / panel.height;
            
            let drawWidth;
            let drawHeight;
            let offsetX = 0; 
            let offsetY = 0;
            
            if (imgAspect > panelAspect) {
              // Image is wider
              drawHeight = panel.height;
              drawWidth = panel.height * imgAspect;
              offsetX = (panel.width - drawWidth) / 2;
            } else {
              // Image is taller
              drawWidth = panel.width;
              drawHeight = panel.width / imgAspect;
              offsetY = (panel.height - drawHeight) / 2;
            }
            
            // Draw the image
            ctx.save();
            ctx.beginPath();
            ctx.rect(panel.x, panel.y, panel.width, panel.height);
            ctx.clip();
            ctx.drawImage(img, panel.x + offsetX, panel.y + offsetY, drawWidth, drawHeight);
            ctx.restore();
            
            resolve();
          };
          
          // Handle image loading errors
          img.onerror = () => {
            logError(`Failed to load image for panel ${panelId}`);
            
            // Redraw with error indicator
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';  // Red with opacity
            ctx.fillRect(panel.x, panel.y, panel.width, panel.height);
            ctx.fillStyle = '#808080';  // Reset fill color
            
            resolve();
          };
          
          // Set image source - with special handling for base64
          if (imageUrl && imageUrl.startsWith('data:image')) {
            img.src = imageUrl;
          } else if (imageUrl) {
            // Add cache busting for regular URLs
            img.src = imageUrl.includes('?') ? imageUrl : `${imageUrl}?t=${Date.now()}`;
            if (!imageUrl.startsWith('blob:')) {
              img.crossOrigin = 'anonymous';
            }
          } else {
            resolve(); // No valid URL, just resolve
          }
        });
        
        imageLoadPromises.push(imgPromise);
      }
    });
    
    // After all images are loaded, draw final borders
    Promise.all(imageLoadPromises).then(() => {
      // Final border pass after all images are drawn
      if (shouldDrawBorder && borderThickness > 0) {
        console.log(`[RENDERER DEBUG] Drawing final borders with thickness: ${borderThickness}, color: ${borderColor}`);
        
        // NEW APPROACH: Draw borders around each panel directly instead of grid lines
        // This ensures complex layouts with spanning areas are rendered correctly
        
        // Ensure we use the correct border color and thickness
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderThickness;

        // First identify all unique edges to avoid double-drawing borders
        const edges = new Map(); // Map of edge key to edge object
        
        // Helper to create a unique key for an edge - with better error checking
        const getEdgeKey = (x1, y1, x2, y2) => {
          // Ensure all inputs are valid numbers
          if (!Number.isFinite(x1) || !Number.isFinite(y1) || !Number.isFinite(x2) || !Number.isFinite(y2)) {
            console.error('Invalid coordinates for edge key:', { x1, y1, x2, y2 });
            return 'invalid-edge'; // Return a placeholder to avoid crashes
          }
          
          // Normalize coordinates to ensure the same edge from either direction has the same key
          const [minX, maxX] = x1 < x2 ? [x1, x2] : [x2, x1];
          const [minY, maxY] = y1 < y2 ? [y1, y2] : [y2, y1];
          
          return `${minX.toFixed(2)}-${minY.toFixed(2)}-${maxX.toFixed(2)}-${maxY.toFixed(2)}`;
        };
        
        // Collect all panel edges
        newPanelRegions.forEach(panel => {
          // Ensure valid coordinates before creating edges
          if (!panel || typeof panel.x !== 'number' || typeof panel.y !== 'number' || 
              typeof panel.width !== 'number' || typeof panel.height !== 'number') {
            console.error('Invalid panel region:', panel);
            return; // Skip this panel
          }
          
          // Use safe calculation and verify values
          const x = panel.x;
          const y = panel.y;
          const right = x + panel.width;
          const bottom = y + panel.height;
          
          // Add edges only if coordinates are valid (defensive programming)
          if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(right) && Number.isFinite(bottom)) {
            try {
              // Top edge
              edges.set(getEdgeKey(x, y, right, y), { x1: x, y1: y, x2: right, y2: y });
              // Right edge
              edges.set(getEdgeKey(right, y, right, bottom), { x1: right, y1: y, x2: right, y2: bottom });
              // Bottom edge
              edges.set(getEdgeKey(x, bottom, right, bottom), { x1: x, y1: bottom, x2: right, y2: bottom });
              // Left edge
              edges.set(getEdgeKey(x, y, x, bottom), { x1: x, y1: y, x2: x, y2: bottom });
            } catch (e) {
              console.error('Error adding edge:', e, panel);
            }
          } else {
            console.error('Invalid panel coordinates:', panel);
          }
        });
        
        // Draw each unique edge once with proper offset
        edges.forEach((edge, key) => {
          if (key === 'invalid-edge' || !edge || 
              !Number.isFinite(edge.x1) || !Number.isFinite(edge.y1) || 
              !Number.isFinite(edge.x2) || !Number.isFinite(edge.y2)) {
            return; // Skip invalid edges
          }
          
          const offset = borderThickness / 2;
          let { x1, y1, x2, y2 } = edge;
          
          // If it's an outer edge, adjust it inward
          if (Math.abs(x1) < 0.01) x1 = offset;
          if (Math.abs(y1) < 0.01) y1 = offset;
          if (Math.abs(x2 - width) < 0.01) x2 = width - offset;
          if (Math.abs(y2 - height) < 0.01) y2 = height - offset;
          
          try {
            // Draw the line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          } catch (e) {
            console.error('Error drawing edge:', e, edge);
          }
        });
        
        try {
          // Draw the outer canvas border with proper thickness
          ctx.strokeRect(
            borderThickness / 2, 
            borderThickness / 2, 
            width - borderThickness, 
            height - borderThickness
          );
        } catch (e) {
          console.error('Error drawing outer border:', e);
        }
      }
      
      // Update the final image
      if (canvas instanceof OffscreenCanvas) {
        canvas.convertToBlob({ type: 'image/png' })
          .then(blob => {
            const url = URL.createObjectURL(blob);
            setRenderedImage(url);
          })
          .catch(err => {
            logError('Error converting canvas to blob:', err);
            if (canvasRef && canvasRef.current) {
              setRenderedImage(canvasRef.current.toDataURL('image/png'));
            }
          });
      } else {
        try {
          setRenderedImage(canvas.toDataURL('image/png'));
        } catch (err) {
          logError('Error converting canvas to data URL:', err);
        }
      }
    });
    
    // Update panel regions state
    setPanelRegions(newPanelRegions);
  } catch (error) {
    logError('Error during template rendering:', error);
    
    // Provide a basic fallback
    if (canvas) {
      ctx.fillStyle = '#ccc';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#555';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Error rendering template', width/2, height/2);
      
      try {
        if (canvas instanceof OffscreenCanvas) {
          canvas.convertToBlob({ type: 'image/png' })
            .then(blob => {
              const url = URL.createObjectURL(blob);
              setRenderedImage(url);
            })
            .catch(() => {
              if (canvasRef && canvasRef.current) {
                setRenderedImage(canvasRef.current.toDataURL('image/png'));
              }
            });
        } else {
          setRenderedImage(canvas.toDataURL('image/png'));
        }
      } catch (err) {
        logError('Error generating fallback image:', err);
      }
    }
  }
}; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/utils/CollageGenerator.js ===

import { renderTemplateToCanvas } from './CanvasLayoutRenderer';
import { sanitizePanelImageMapping, createPanelToImageUrlMapping } from './PanelMappingUtils';

/**
 * Service for collage generation
 */

/**
 * Draw an upload icon in the center of an empty panel
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} panel - Panel region
 * @param {string} color - Color of the icon (used only for the plus sign)
 */
const drawUploadIcon = (ctx, panel, color = '#FFFFFF') => {
  const { x, y, width, height, consistentIconSize } = panel;
  const centerX = x + width / 2;
  const centerY = y + height / 2;
  
  // Save the current state
  ctx.save();
  
  // Use the consistent icon size if provided, otherwise calculate it based on the panel
  let iconSize;
  
  if (consistentIconSize !== undefined) {
    iconSize = consistentIconSize;
  } else {
    // Size the icon proportionally to the panel, but cap the maximum size
    // to 8% of the largest panel dimension (reduced from 10%)
    const maxSize = Math.max(width, height) * 0.08;
    const calculatedSize = Math.min(width, height) * 0.15; // Reduced from 0.18
    iconSize = Math.min(calculatedSize, maxSize);
  }
  
  // Draw a solid blue circle
  ctx.fillStyle = '#3b82f6'; // Bright blue color
  ctx.beginPath();
  ctx.arc(centerX, centerY, iconSize, 0, Math.PI * 2);
  ctx.fill();
  
  // Add white border around the circle
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = Math.max(2, iconSize * 0.08); // Proportional white border
  ctx.beginPath();
  ctx.arc(centerX, centerY, iconSize, 0, Math.PI * 2);
  ctx.stroke();
  
  // Set style for the plus sign
  ctx.strokeStyle = '#FFFFFF'; // Always white plus sign for good contrast
  
  // Draw a heavy plus sign (smaller than before)
  const plusSize = iconSize * 0.45; // Smaller plus (was 0.6)
  const lineWidth = Math.max(2, iconSize * 0.12); // Thicker line for better visibility
  
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round'; // Rounded ends for better appearance
  
  // Horizontal line of plus
  ctx.beginPath();
  ctx.moveTo(centerX - plusSize, centerY);
  ctx.lineTo(centerX + plusSize, centerY);
  ctx.stroke();
  
  // Vertical line of plus
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - plusSize);
  ctx.lineTo(centerX, centerY + plusSize);
  ctx.stroke();
  
  // Restore the canvas state
  ctx.restore();
};

/**
 * Get the border thickness value, adjusted for panel count
 * @param {string|number} borderThickness - The border thickness label or value
 * @param {Array} borderThicknessOptions - Options for border thickness
 * @param {number} panelCount - Number of panels in the collage
 * @returns {number} - The adjusted border thickness value
 */
const getBorderThicknessValue = (borderThickness, borderThicknessOptions, panelCount = 2) => {
  console.log(`[DEBUG] getBorderThicknessValue - Initial borderThickness: ${borderThickness}, panelCount: ${panelCount}`);
  
  let rawThickness;
  
  // If borderThickness is already a number, return it directly
  if (typeof borderThickness === 'number') {
    console.log(`[DEBUG] borderThickness is a number: ${borderThickness}`);
    rawThickness = borderThickness;
  }
  // If it's a string that can be parsed as a number, return the parsed value
  else if (typeof borderThickness === 'string' && !Number.isNaN(parseFloat(borderThickness))) {
    rawThickness = parseFloat(borderThickness);
    console.log(`[DEBUG] borderThickness parsed from string: ${rawThickness}`);
  }
  // Try to find by label in the options
  else {
    // Log the available options for debugging
    console.log(`[DEBUG] Available borderThicknessOptions:`, 
      borderThicknessOptions.map(opt => `${opt.label}: ${opt.value}`).join(', '));
    
    const matchingOption = borderThicknessOptions.find(
      option => option.label.toLowerCase() === borderThickness.toLowerCase()
    );
    
    if (matchingOption) {
      rawThickness = matchingOption.value;
      console.log(`[DEBUG] Found matching option: ${matchingOption.label} = ${rawThickness}`);
    }
    // If no match found, try to find 'medium' as fallback
    else {
      const mediumOption = borderThicknessOptions.find(
        option => option.label.toLowerCase() === 'medium'
      );
      
      if (mediumOption) {
        console.log(`[DEBUG] Border thickness '${borderThickness}' not found, using 'medium' instead`);
        rawThickness = mediumOption.value;
      }
      else {
        // Absolute fallback
        console.log(`[DEBUG] No matching border thickness found for '${borderThickness}', using default`);
        rawThickness = 30; // Default to a sensible medium value if all else fails
      }
    }
  }
  
  // Get adjusted thickness
  const adjustedThickness = adjustForPanelCount(rawThickness, panelCount);
  console.log(`[DEBUG] Raw thickness: ${rawThickness}, After panel count adjustment: ${adjustedThickness} (panelCount: ${panelCount})`);
  
  return adjustedThickness;
};

/**
 * Adjust border thickness based on panel count
 * Scales down thickness significantly as panel count increases
 * @param {number} thickness - Original thickness value
 * @param {number} panelCount - Number of panels in the collage
 * @returns {number} - Adjusted thickness value
 */
const adjustForPanelCount = (thickness, panelCount) => {
  console.log(`[DEBUG] adjustForPanelCount - Original thickness: ${thickness}, panelCount: ${panelCount}`);
  
  if (panelCount <= 2) {
    console.log(`[DEBUG] No adjustment needed for panel count ${panelCount}`);
    return thickness; // No adjustment for 1-2 panels
  }
  
  // Apply a more aggressive scaling for more panels to ensure borders don't overwhelm the design
  let scaleFactor;
  
  switch (panelCount) {
    case 3:
      scaleFactor = 0.7; // 70% of original thickness for 3 panels
      break;
    case 4:
      scaleFactor = 0.6; // 60% of original thickness for 4 panels
      break;
    case 5:
      scaleFactor = 0.5; // 50% of original thickness for 5 panels
      break;
    default:
      scaleFactor = 0.4; // 40% of original thickness for 6+ panels (very aggressive reduction)
      break;
  }
  
  console.log(`[DEBUG] Using scale factor: ${scaleFactor} for panel count: ${panelCount}`);
  
  // Ensure minimum thickness of 1 pixel
  const adjusted = Math.max(1, Math.round(thickness * scaleFactor));
  console.log(`[DEBUG] Final adjusted thickness: ${adjusted} (original: ${thickness}, scale: ${scaleFactor})`);
  return adjusted;
};

/**
 * Finds the dimensions of the smallest panel in the layout
 * @param {Array} panelRegions - Array of panel region objects
 * @returns {Object} - Object containing the minimum width and height
 */
const findSmallestPanelDimensions = (panelRegions) => {
  if (!panelRegions || panelRegions.length === 0) {
    return { minWidth: 100, minHeight: 100 }; // Default fallback
  }
  
  // Find the smallest panel dimensions
  let minWidth = Infinity;
  let minHeight = Infinity;
  
  panelRegions.forEach(panel => {
    if (panel.width < minWidth) minWidth = panel.width;
    if (panel.height < minHeight) minHeight = panel.height;
  });
  
  return { minWidth, minHeight };
};

/**
 * Generate a collage from the selected images, template, etc.
 * @param {Object} options - Options for collage generation
 * @returns {Promise<string>} - Promise resolving to the data URL of the generated collage
 */
export const generateCollage = async ({
  selectedTemplate,
  selectedAspectRatio,
  panelCount,
  selectedImages,
  panelImageMapping,
  borderThickness,
  borderColor = '#FFFFFF', // Default to white if not provided
  borderThicknessOptions,
  theme
}) => {
  console.log(`[DEBUG] generateCollage - panelCount: ${panelCount}, borderThickness: ${borderThickness}`);
  console.log(`[DEBUG] borderThicknessOptions:`, borderThicknessOptions);
  
  try {
    // Sanitize the panel mapping
    const cleanMapping = sanitizePanelImageMapping(panelImageMapping, selectedImages, panelCount);
    
    // Get the numeric border thickness value
    const borderThicknessValue = getBorderThicknessValue(borderThickness, borderThicknessOptions, panelCount);
    console.log(`[DEBUG] After getBorderThicknessValue - borderThicknessValue: ${borderThicknessValue}`);
    
    // Call the canvas renderer to create the collage
    const { width, height, canvasRef, dataUrl, panelRegions } = await renderCollage({
      selectedTemplate,
      selectedAspectRatio,
      borderThicknessValue,
      borderColor,
      panelCount,
      theme
    });
    
    if (!canvasRef.current || !panelRegions || panelRegions.length === 0) {
      throw new Error('Failed to create canvas or panel regions');
    }
    
    // Get the canvas context
    const ctx = canvasRef.current.getContext('2d');
    if (!ctx) {
      throw new Error('Failed to get canvas context');
    }
    
    // Draw the images onto the canvas
    await drawImagesToCanvas({
      ctx,
      width,
      height, 
      panelRegions, 
      selectedImages, 
      cleanMapping,
      borderThicknessValue,
      borderColor,
      theme,
      panelCount
    });
    
    // Return the data URL
    return canvasRef.current.toDataURL('image/png');
  } catch (error) {
    console.error('Error generating collage:', error);
    throw error;
  }
};

/**
 * Render the collage layout to a canvas
 */
const renderCollage = async ({
  selectedTemplate,
  selectedAspectRatio,
  borderThicknessValue,
  borderColor = '#FFFFFF', // Add default border color
  panelCount,
  theme
}) => {
  console.log(`[DEBUG] renderCollage - borderThicknessValue: ${borderThicknessValue}, panelCount: ${panelCount}`);
  
  // Create canvas regions for the collage
  const panelRegions = [];
  const canvasRef = { current: document.createElement('canvas') };
  
  // Adjust border thickness based on panel count
  const adjustedBorderThickness = adjustForPanelCount(borderThicknessValue, panelCount);
  console.log(`[DEBUG] renderCollage - adjustedBorderThickness: ${adjustedBorderThickness} (original: ${borderThicknessValue})`);
  
  // Promise to capture panel regions
  await new Promise(resolve => {
    const setRenderedImage = () => {};
    const setPanelRegions = (regions) => {
      panelRegions.push(...regions);
      resolve();
    };
    
    console.log(`[DEBUG] About to call renderTemplateToCanvas with borderThickness: ${adjustedBorderThickness}`);
    renderTemplateToCanvas({
      selectedTemplate,
      selectedAspectRatio,
      panelCount,
      theme,
      canvasRef,
      setPanelRegions,
      setRenderedImage,
      borderThickness: adjustedBorderThickness,
      borderColor
    });
  });
  
  return { 
    width: canvasRef.current.width, 
    height: canvasRef.current.height,
    canvasRef,
    panelRegions 
  };
};

/**
 * Draw images onto the collage canvas
 */
const drawImagesToCanvas = async ({
  ctx,
  width,
  height,
  panelRegions,
  selectedImages,
  cleanMapping,
  borderThicknessValue,
  borderColor = '#FFFFFF', // Default to white if not provided
  theme,
  panelCount
}) => {
  console.log(`[DEBUG] drawImagesToCanvas - borderThicknessValue: ${borderThicknessValue}, borderColor: ${borderColor}, panelCount: ${panelCount}`);
  
  if (selectedImages.length === 0) return;
  
  // Ensure border thickness is properly adjusted for panel count
  const adjustedBorderThickness = adjustForPanelCount(borderThicknessValue, panelCount);
  console.log(`[DEBUG] drawImagesToCanvas - adjustedBorderThickness: ${adjustedBorderThickness} (original: ${borderThicknessValue})`);
  
  // Create a mapping from panel ID to image URL
  const panelToImageUrl = createPanelToImageUrlMapping(cleanMapping, selectedImages, panelRegions);
  
  // Clear the canvas
  ctx.clearRect(0, 0, width, height);
  
  // Set background color
  ctx.fillStyle = theme.palette.mode === 'dark' ? '#121212' : '#f5f5f5';
  ctx.fillRect(0, 0, width, height);
  
  // Find the smallest panel dimensions for consistent icon sizing
  const { minWidth, minHeight } = findSmallestPanelDimensions(panelRegions);
  
  // Draw placeholders for all panels first
  panelRegions.forEach(panel => {
    if (!panel.id) return;
    
    // Draw grey placeholder for all panels
    ctx.fillStyle = '#808080';
    ctx.fillRect(panel.x, panel.y, panel.width, panel.height);
    
    // Check if this panel has an image assigned in the mapping
    const hasImage = panelToImageUrl[panel.id] !== undefined;
    
    // Draw upload icon if panel is empty
    if (!hasImage) {
      // Use either white or dark gray based on theme to ensure visibility
      const iconColor = theme.palette.mode === 'dark' ? '#FFFFFF' : '#555555';
      
      // Calculate consistent icon size based on the smallest panel dimensions
      const maxConsistentSize = Math.max(minWidth, minHeight) * 0.08;
      const calculatedConsistentSize = Math.min(minWidth, minHeight) * 0.15;
      const consistentIconSize = Math.min(calculatedConsistentSize, maxConsistentSize);
      
      // Keep original panel position but use consistent size
      drawUploadIcon(ctx, {
        x: panel.x, 
        y: panel.y,
        width: panel.width,
        height: panel.height,
        consistentIconSize
      }, iconColor);
    }
  });
  
  // We'll skip the initial border pass and only draw borders once at the end
  
  // Collection of promises for loading images
  const imageLoadPromises = [];
  
  // Draw each panel with its assigned image
  panelRegions.forEach(panel => {
    // Ensure panel has a valid ID
    if (!panel.id) return;
    
    const imageUrl = panelToImageUrl[panel.id];
    
    if (imageUrl) {
      const promise = new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          // Draw the image within its panel region
          ctx.save();
          ctx.beginPath();
          ctx.rect(panel.x, panel.y, panel.width, panel.height);
          ctx.clip();
          
          // Calculate dimensions to maintain aspect ratio while filling the panel
          const imgAspect = img.width / img.height;
          const panelAspect = panel.width / panel.height;
          
          let drawWidth = 0;
          let drawHeight = 0;
          let drawX = 0;
          let drawY = 0;
          
          if (imgAspect > panelAspect) {
            // Image is wider than panel (proportionally)
            drawHeight = panel.height;
            drawWidth = drawHeight * imgAspect;
            drawX = panel.x + (panel.width - drawWidth) / 2;
            drawY = panel.y;
          } else {
            // Image is taller than panel (proportionally)
            drawWidth = panel.width;
            drawHeight = drawWidth / imgAspect;
            drawX = panel.x;
            drawY = panel.y + (panel.height - drawHeight) / 2;
          }
          
          // Draw the image scaled to fill the panel
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
          ctx.restore();
          
          resolve();
        };
        
        img.onerror = () => {
          console.error(`Failed to load image: ${imageUrl}`);
          // Draw placeholder for failed image
          ctx.save();
          ctx.fillStyle = '#FF6B6B';
          ctx.fillRect(panel.x, panel.y, panel.width, panel.height);
          ctx.restore();
          resolve(); // Still resolve so we don't block other images
        };
        
        img.src = imageUrl;
      });
      
      imageLoadPromises.push(promise);
    }
  });
  
  // Wait for all images to load and render
  await Promise.all(imageLoadPromises);
  
  // Final border pass to ensure borders are on top of all images
  if (adjustedBorderThickness > 0) {
    console.log(`[DEBUG] Drawing final borders with thickness: ${adjustedBorderThickness}, color: ${borderColor}`);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = adjustedBorderThickness;
    
    // Calculate the unique grid lines (rows and columns) from panel positions
    const horizontalLines = new Set();
    const verticalLines = new Set();
    
    // Find all unique grid lines from panel positions
    panelRegions.forEach(panel => {
      if (!panel.id) return;
      
      // Top and bottom edges
      horizontalLines.add(panel.y);
      horizontalLines.add(panel.y + panel.height);
      
      // Left and right edges
      verticalLines.add(panel.x);
      verticalLines.add(panel.x + panel.width);
    });
    
    // Convert sets to sorted arrays
    const hLines = Array.from(horizontalLines).sort((a, b) => a - b);
    const vLines = Array.from(verticalLines).sort((a, b) => a - b);
    
    // Draw all horizontal grid lines with proper alignment
    hLines.forEach(y => {
      let drawY = y;
      
      // Adjust position to ensure consistent visual thickness
      if (y === hLines[0]) {
        // Top edge: move inward by half border thickness
        drawY = y + adjustedBorderThickness / 2;
      } else if (y === hLines[hLines.length - 1]) {
        // Bottom edge: move inward by half border thickness
        drawY = y - adjustedBorderThickness / 2;
      }
      
      ctx.beginPath();
      ctx.moveTo(vLines[0], drawY);
      ctx.lineTo(vLines[vLines.length - 1], drawY);
      ctx.stroke();
    });
    
    // Draw all vertical grid lines with proper alignment
    vLines.forEach(x => {
      let drawX = x;
      
      // Adjust position to ensure consistent visual thickness
      if (x === vLines[0]) {
        // Left edge: move inward by half border thickness
        drawX = x + adjustedBorderThickness / 2;
      } else if (x === vLines[vLines.length - 1]) {
        // Right edge: move inward by half border thickness
        drawX = x - adjustedBorderThickness / 2;
      }
      
      ctx.beginPath();
      ctx.moveTo(drawX, hLines[0]);
      ctx.lineTo(drawX, hLines[hLines.length - 1]);
      ctx.stroke();
    });
  }
}; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/utils/PanelMappingUtils.js ===

/**
 * Utility functions for handling panel-to-image mapping
 */

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

/**
 * Ensures panel mapping is valid
 * @param {Object} mapping - Object mapping panel IDs to image indices 
 * @param {Array} imageArray - Array of images to map from
 * @param {Number} panelCount - Number of panels in layout
 * @returns {Object} - Sanitized mapping with only valid entries
 */
export const sanitizePanelImageMapping = (mapping, imageArray, panelCount) => {
  if (!mapping || typeof mapping !== 'object') {
    if (DEBUG_MODE) {
      console.log("Panel mapping is invalid or missing:", mapping);
    }
    return {};
  }
  
  // Debug info about current mapping state
  if (DEBUG_MODE) {
    console.log("Panel mapping before sanitization:", {
      mappingKeys: Object.keys(mapping),
      imageArrayLength: imageArray?.length || 0,
      panelCount
    });
  }
  
  // Create a clean mapping object with only valid entries
  const cleanMapping = {};
  
  Object.entries(mapping).forEach(([panelId, imageIndex]) => {
    // Convert panelId to number if it's a string number
    const numericPanelId = !Number.isNaN(Number(panelId)) ? Number(panelId) : panelId;
    
    // Check if this mapping is valid
    const isValid = imageIndex !== undefined && 
                    imageIndex >= 0 && 
                    imageIndex < imageArray.length && 
                    imageArray[imageIndex];
    
    if (isValid) {
      cleanMapping[numericPanelId] = imageIndex;
    } else if (DEBUG_MODE) {
      console.log(`Invalid panel mapping: panel ${panelId} -> image ${imageIndex}`, {
        reason: !imageIndex && imageIndex !== 0 ? "No image index" : 
                imageIndex < 0 ? "Negative index" :
                imageIndex >= imageArray.length ? "Index out of bounds" :
                !imageArray[imageIndex] ? "Image not found at index" : "Unknown"
      });
    }
  });
  
  if (DEBUG_MODE) {
    console.log("Sanitized panel mapping:", cleanMapping);
  }
  return cleanMapping;
};

/**
 * Safely preserves panel image mapping when an image is updated or replaced
 * @param {Object} currentMapping - Current panel-to-image-index mapping
 * @param {Number} updatedImageIndex - Index of the image that was updated
 * @param {Array} selectedImages - Array of all selected images
 * @returns {Object} - Updated mapping with fixed indices if needed
 */
export const preserveMappingOnImageUpdate = (currentMapping, updatedImageIndex, selectedImages) => {
  if (!currentMapping || Object.keys(currentMapping).length === 0) {
    return currentMapping;
  }
  
  if (DEBUG_MODE) {
    console.log("Preserving mapping for updated image at index:", updatedImageIndex, 
      "Current mapping:", currentMapping);
  }
  
  // Create a deep copy of the mapping to avoid mutation issues
  const newMapping = JSON.parse(JSON.stringify(currentMapping));
  
  // Nothing needs to be done if the mapping already points to valid images
  return newMapping;
};

/**
 * Creates a mapping from panel IDs to image URLs
 * @param {Object} cleanMapping - Sanitized panel-to-image-index mapping
 * @param {Array} selectedImages - Array of image URLs
 * @param {Array} panelRegions - Array of panel region objects
 * @returns {Object} - Mapping from panel IDs to image URLs
 */
export const createPanelToImageUrlMapping = (cleanMapping, selectedImages, panelRegions) => {
  const panelToImageUrl = {};
  
  // Add debug logging
  if (DEBUG_MODE) {
    console.log("Creating image URL mapping from:", {
      mappingEntries: Object.entries(cleanMapping || {}),
      imageCount: selectedImages?.length || 0,
      panelCount: panelRegions?.length || 0
    });
  }
  
  try {
    // Use the existing mapping if available
    if (cleanMapping && Object.keys(cleanMapping).length > 0) {
      // Use the existing mapping - panel ID to image index
      Object.entries(cleanMapping).forEach(([panelId, imageIndex]) => {
        if (selectedImages[imageIndex]) {
          const imageItem = selectedImages[imageIndex];
          const imageUrl = typeof imageItem === 'object' && imageItem !== null 
            ? (imageItem.url || imageItem.imageUrl || imageItem) 
            : imageItem;
          
          if (imageUrl) {
            if (DEBUG_MODE) {
              console.log(`Mapping panel ${panelId} to image ${imageIndex} with URL: ${typeof imageUrl === 'string' ? `${imageUrl.substring(0, 30)}...` : '[object]'}`);
            }
            panelToImageUrl[panelId] = imageUrl;
          } else if (DEBUG_MODE) {
            console.log(`Warning: No valid URL for image at index ${imageIndex} for panel ${panelId}`);
          }
        } else if (DEBUG_MODE) {
          console.log(`Warning: No image found at index ${imageIndex} for panel ${panelId}`);
        }
      });
    } else if (panelRegions && panelRegions.length > 0 && selectedImages && selectedImages.length > 0) {
      // Assign images sequentially to panels
      if (DEBUG_MODE) {
        console.log("No mapping provided, creating sequential mapping");
      }
      panelRegions.forEach((panel, index) => {
        if (index < selectedImages.length && selectedImages[index]) {
          const imageItem = selectedImages[index];
          const imageUrl = typeof imageItem === 'object' && imageItem !== null 
            ? (imageItem.url || imageItem.imageUrl || imageItem) 
            : imageItem;
          
          if (imageUrl) {
            if (DEBUG_MODE) {
              console.log(`Sequential mapping: panel ${panel.id} to image ${index}`);
            }
            panelToImageUrl[panel.id] = imageUrl;
          }
        }
      });
    } else if (DEBUG_MODE) {
      console.log("Insufficient data to create panel-to-image mapping");
    }
  } catch (error) {
    console.error("Error creating panel to image URL mapping:", error);
  }
  
  return panelToImageUrl;
}; 

=== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/hooks/useCollageState.js ===

import { useState, useEffect } from 'react';
import { getLayoutsForPanelCount } from '../config/CollageConfig';

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

/**
 * Custom hook to manage collage state
 */
export const useCollageState = () => {
  const [selectedImages, setSelectedImages] = useState([]);
  const [panelImageMapping, setPanelImageMapping] = useState({});
  const [selectedTemplate, setSelectedTemplate] = useState(null);
  const [selectedAspectRatio, setSelectedAspectRatio] = useState('portrait');
  const [panelCount, setPanelCount] = useState(2); // Default panel count of 2
  const [finalImage, setFinalImage] = useState(null);
  const [isCreatingCollage, setIsCreatingCollage] = useState(false);
  const [borderThickness, setBorderThickness] = useState('medium'); // Default border thickness
  
  // Get the saved custom color from localStorage if available, otherwise use white
  const [borderColor, setBorderColor] = useState(() => {
    const savedCustomColor = localStorage.getItem('meme-src-collage-custom-color');
    return savedCustomColor || '#FFFFFF'; // Default white border color
  });

  // Save the custom color to localStorage when it changes
  useEffect(() => {
    localStorage.setItem('meme-src-collage-custom-color', borderColor);
  }, [borderColor]);

  // Initialize template on mount
  useEffect(() => {
    if (DEBUG_MODE) {
      console.log("useCollageState initializing...");
    }
    
    // Get compatible templates for initial panel count and aspect ratio
    const initialTemplates = getLayoutsForPanelCount(panelCount, selectedAspectRatio);
    
    if (DEBUG_MODE) {
      console.log("Initial templates:", {
        count: initialTemplates.length,
        panelCount,
        aspectRatio: selectedAspectRatio
      });
    }
    
    // Set the initial template if available
    if (initialTemplates.length > 0) {
      if (DEBUG_MODE) {
        console.log("Setting initial template:", initialTemplates[0].id);
      }
      setSelectedTemplate(initialTemplates[0]);
    } else {
      console.warn("No initial templates found!");
    }
  }, []); // Empty dependency array ensures this runs only once on mount

  // Select the most suitable template when panel count or aspect ratio changes
  useEffect(() => {
    const compatibleTemplates = getLayoutsForPanelCount(panelCount, selectedAspectRatio);
    
    // If no template is selected or the current one isn't compatible, select the first one
    if (!selectedTemplate || 
        selectedTemplate.minImages > panelCount || 
        selectedTemplate.maxImages < panelCount) {
      
      if (compatibleTemplates.length > 0) {
        // Select the first (highest priority) compatible template
        setSelectedTemplate(compatibleTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  }, [panelCount, selectedAspectRatio, selectedTemplate]);

  // Clean up ObjectURLs when component unmounts or when images are replaced
  useEffect(() => {
    return () => {
      selectedImages.forEach(url => {
        if (url && typeof url === 'string' && url.startsWith('blob:')) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [selectedImages]);

  /**
   * Add a new image to the collection
   * @param {string|Object} image - The image URL or object to add
   */
  const addImage = (image) => {
    setSelectedImages([...selectedImages, image]);
  };

  /**
   * Remove an image by index
   * @param {number} index - The index of the image to remove
   */
  const removeImage = (index) => {
    // Create a copy of the images array without the removed image
    const newImages = [...selectedImages];
    const removedImage = newImages.splice(index, 1)[0];
    
    // Clean up the object URL if it's a blob URL
    if (removedImage && typeof removedImage === 'string' && removedImage.startsWith('blob:')) {
      URL.revokeObjectURL(removedImage);
    }
    
    setSelectedImages(newImages);
    
    // Also update panel mapping to remove references to this image
    const newMapping = {};
    Object.entries(panelImageMapping).forEach(([panelId, mappedIndex]) => {
      if (mappedIndex === index) {
        // This panel was pointing to the removed image, so remove the mapping
        // (do nothing, which will remove it from newMapping)
      } else if (mappedIndex > index) {
        // This panel was pointing to an image after the removed one, so adjust the index
        newMapping[panelId] = mappedIndex - 1;
      } else {
        // This panel points to an image before the removed one, so keep it the same
        newMapping[panelId] = mappedIndex;
      }
    });
    
    setPanelImageMapping(newMapping);
  };

  /**
   * Update an image at a specific index
   * @param {number} index - The index of the image to update
   * @param {string|Object} newImage - The new image URL or object
   */
  const updateImage = (index, newImage) => {
    if (index >= 0 && index < selectedImages.length) {
      const oldImage = selectedImages[index];
      // Clean up the old image URL if it's a blob
      if (oldImage && typeof oldImage === 'string' && oldImage.startsWith('blob:')) {
        URL.revokeObjectURL(oldImage);
      }
      
      // Create a new array with the updated image
      const newImages = [...selectedImages];
      newImages[index] = newImage;
      setSelectedImages(newImages);
    }
  };

  /**
   * Clear all selected images
   */
  const clearImages = () => {
    // Clean up all blob URLs
    selectedImages.forEach(image => {
      if (image && typeof image === 'string' && image.startsWith('blob:')) {
        URL.revokeObjectURL(image);
      }
    });
    
    setSelectedImages([]);
    setPanelImageMapping({});
  };

  /**
   * Update the mapping between panels and images
   * @param {Object} newMapping - The new panel-to-image mapping
   */
  const updatePanelImageMapping = (newMapping) => {
    if (DEBUG_MODE) {
      console.log("Updating panel image mapping:", {
        previous: Object.keys(panelImageMapping),
        new: Object.keys(newMapping),
        changes: Object.keys(newMapping).filter(key => 
          panelImageMapping[key] !== newMapping[key]
        )
      });
    }
    
    setPanelImageMapping(newMapping);
  };

  return {
    // State
    selectedImages,
    panelImageMapping,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    finalImage,
    setFinalImage,
    isCreatingCollage,
    setIsCreatingCollage,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    
    // Operations
    addImage,
    removeImage,
    updateImage,
    clearImages,
    updatePanelImageMapping,
  };
}; 