

===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/pages/CollagePage.js =====

import { useContext, useState, useEffect } from "react";
import { Helmet } from "react-helmet-async";
import { useTheme } from "@mui/material/styles";
import { useMediaQuery } from "@mui/material";
import { Dashboard } from "@mui/icons-material";

import { UserContext } from "../UserContext";
import { useSubscribeDialog } from "../contexts/useSubscribeDialog";

// Import configuration
import { aspectRatioPresets, layoutTemplates, getLayoutsForPanelCount } from "../components/collage/config/CollageConfig";

// Import components from steps
import CollageImagesStep from "../components/collage/steps/CollageImagesStep";
import CollageSettingsStep from "../components/collage/steps/CollageSettingsStep";
import UpgradeMessage from "../components/collage/components/UpgradeMessage";

// Import UI components
import { PageHeader } from "../components/collage/components/CollageUIComponents";
import { 
  MainContainer, 
  ContentPaper, 
  CollageLayout,
  CollageResult 
} from "../components/collage/components/CollageLayoutComponents";

// Import utilities for collage generation
import { 
  calculateCanvasDimensions, 
  getAspectRatioValue
} from "../components/collage/utils/CanvasLayoutRenderer";

// Import the new collage generation service
import { generateCollage } from "../components/collage/utils/CollageGenerator";

// Import the panel mapping utilities
import { sanitizePanelImageMapping } from "../components/collage/utils/PanelMappingUtils";

// Import state management custom hook
import { useCollageState } from "../components/collage/hooks/useCollageState";

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

// Helper debug logger function that only logs when DEBUG_MODE is true
const debugLog = (...args) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Helper for warnings that should still show in production
const debugWarn = (...args) => {
  if (DEBUG_MODE) {
    console.warn(...args);
  } else if (args[0] && args[0].includes('critical')) {
    // Allow critical warnings to show even in production
    console.warn(...args);
  }
};

// Helper for errors that should always show
const logError = (...args) => {
  console.error(...args);
};

// Collage page component - provides UI for creating collages
export default function CollagePage() {
  // Access theme for responsiveness and custom styling
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const isMediumScreen = useMediaQuery(theme.breakpoints.down('md'));
  
  // User authentication and subscription context
  const { user } = useContext(UserContext);
  const { openSubscriptionDialog } = useSubscribeDialog();
  
  // Determine if user is authorized to use the collage tool
  const authorized = (user?.userDetails?.magicSubscription === "true" || user?.['cognito:groups']?.includes('admins'));
  
  // Use our custom hook to manage collage state
  const {
    selectedImages,
    panelImageMapping,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    finalImage,
    setFinalImage,
    isCreatingCollage,
    setIsCreatingCollage,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    addImage,
    removeImage,
    updateImage,
    clearImages,
    updatePanelImageMapping,
  } = useCollageState();
  
  // Define border thickness options
  const borderThicknessOptions = [
    { label: "None", value: 0 },
    { label: "Thin", value: 6 },
    { label: "Medium", value: 16 },
    { label: "Thicc", value: 40 },
    { label: "Thiccer", value: 80 },
    { label: "XTRA THICC", value: 120 }
  ];

  // Get layouts compatible with the current panel count and aspect ratio
  const getCompatibleTemplates = () => {
    // Get all templates for the current panel count
    const panelTemplates = getLayoutsForPanelCount(panelCount);
    
    // Filter by aspect ratio compatibility
    const aspectRatioCategory = getAspectRatioPreset(selectedAspectRatio)?.category || 'any';
    
    const compatibleTemplates = panelTemplates.filter(template => {
      // Template is compatible if it has no aspect ratio constraint or matches the current one
      return !template.aspectRatioCategory || template.aspectRatioCategory === aspectRatioCategory || template.aspectRatioCategory === 'any';
    });
    
    // Sort by priority (lower number = higher priority)
    return compatibleTemplates.sort((a, b) => {
      if (a.priority !== undefined && b.priority !== undefined) {
        return a.priority - b.priority;
      }
      return 0;
    });
  };

  // Helper function to get the aspect ratio preset from its ID
  const getAspectRatioPreset = (id) => {
    return aspectRatioPresets.find(preset => preset.id === id);
  };

  // Select the most suitable template when panel count or aspect ratio changes
  useEffect(() => {
    const compatibleTemplates = getCompatibleTemplates();
    
    // If no template is selected or the current one isn't compatible, select the first one
    if (!selectedTemplate || 
        selectedTemplate.minImages > panelCount || 
        selectedTemplate.maxImages < panelCount) {
      
      if (compatibleTemplates.length > 0) {
        // Select the first (highest priority) compatible template
        setSelectedTemplate(compatibleTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  }, [panelCount, selectedAspectRatio, selectedTemplate]);

  // Submit the collage for creation
  const handleCreateCollage = async () => {
    setIsCreatingCollage(true);
    
    try {
      // Use the collage generator service
      debugLog(`[PAGE DEBUG] Creating collage with panelCount: ${panelCount}, borderThickness: ${borderThickness}, borderColor: ${borderColor}`);
      debugLog(`[PAGE DEBUG] borderThicknessOptions:`, borderThicknessOptions);
      
      const dataUrl = await generateCollage({
        selectedTemplate,
        selectedAspectRatio,
        panelCount,
        selectedImages,
        panelImageMapping,
        borderThickness,
        borderColor,
        borderThicknessOptions,
        theme
      });
      
      setFinalImage(dataUrl);
    } catch (error) {
      logError('Error generating collage:', error);
    } finally {
      setIsCreatingCollage(false);
    }
  };

  // Log changes to border color
  useEffect(() => {
    debugLog(`[PAGE DEBUG] Border color changed to: ${borderColor}`);
  }, [borderColor]);

  // Props for the settings step component
  const settingsStepProps = {
    selectedImages,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    handleNext: handleCreateCollage,
    aspectRatioPresets,
    layoutTemplates,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    borderThicknessOptions
  };
  
  // Props for the images step component
  const imagesStepProps = {
    selectedImages,
    addImage,
    removeImage,
    updateImage,
    clearImages,
    panelImageMapping,
    updatePanelImageMapping,
    panelCount,
    selectedTemplate,
    selectedAspectRatio,
    borderThickness,
    borderColor,
    borderThicknessOptions,
    handleNext: handleCreateCollage
  };

  // Log the panel mapping for debugging
  useEffect(() => {
    if (DEBUG_MODE) {
      debugLog("CollagePage panel mapping updated:", {
        mappingKeys: Object.keys(panelImageMapping),
        imageCount: selectedImages.length
      });
    }
  }, [panelImageMapping, selectedImages.length]);

  return (
    <>
      <Helmet>
        <title>Collage Tool - Editor - memeSRC</title>
      </Helmet>

      {!authorized ? (
        <UpgradeMessage 
          openSubscriptionDialog={openSubscriptionDialog} 
          previewImage="/assets/images/products/collage-tool.png"
        />
      ) : (
        <MainContainer isMobile={isMobile} isMediumScreen={isMediumScreen}>
          <PageHeader icon={Dashboard} title="Collage Tool" isMobile={isMobile} />
          
          <ContentPaper isMobile={isMobile}>
            <CollageLayout 
              settingsStepProps={settingsStepProps} 
              imagesStepProps={imagesStepProps} 
              isMobile={isMobile}
            />

            {finalImage && (
              <CollageResult 
                finalImage={finalImage} 
                setFinalImage={setFinalImage} 
                isMobile={isMobile} 
                isMediumScreen={isMediumScreen}
                isLoading={isCreatingCollage}
              />
            )}
          </ContentPaper>
        </MainContainer>
      )}
    </>
  );
}


===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/steps/CollageImagesStep.js =====

import { useState, useEffect, useRef } from "react";
import { useTheme } from "@mui/material/styles";
import {
  Box,
  Button,
  Typography,
  Paper,
  useMediaQuery
} from "@mui/material";
import { KeyboardArrowLeft, KeyboardArrowRight, Edit } from "@mui/icons-material";

// Import from the collage configuration
import { aspectRatioPresets, getLayoutsForPanelCount } from "../config/CollageConfig";
// Import new layout rendering utilities
import {
  renderTemplateToCanvas,
  getAspectRatioValue,
  calculateCanvasDimensions
} from "../utils/CanvasLayoutRenderer";

// Import the components directly
import UploadOrCropDialog from "../components/UploadOrCropDialog";
import ImageCropModal from "../components/ImageCropModal";

// --- ADD CONSOLE LOGS ---
// Log right after imports to see what was actually imported
console.log("Imported UploadOrCropDialogModule:", UploadOrCropDialog);
console.log("Imported ImageCropModalModule:", ImageCropModal);

// --- END OF MODIFICATIONS ---

/**
 * Adjust border thickness based on panel count
 * Scales down thickness significantly as panel count increases
 * @param {number} thickness - Original thickness value
 * @param {number} panelCount - Number of panels in the collage
 * @returns {number} - Adjusted thickness value
 */
const adjustForPanelCount = (thickness, panelCount) => {
  if (panelCount <= 2) {
    return thickness; // No adjustment for 1-2 panels
  }

  // Apply a more aggressive scaling for more panels
  let scaleFactor;

  switch (panelCount) {
    case 3:
      scaleFactor = 0.7; // 70% of original thickness for 3 panels
      break;
    case 4:
      scaleFactor = 0.6; // 60% of original thickness for 4 panels
      break;
    case 5:
      scaleFactor = 0.5; // 50% of original thickness for 5 panels
      break;
    default:
      scaleFactor = 0.4; // 40% of original thickness for 6+ panels (very aggressive reduction)
      break;
  }

  // Ensure minimum thickness of 1 pixel
  return Math.max(1, Math.round(thickness * scaleFactor));
};

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

// Helper debug logger function that only logs when DEBUG_MODE is true
const debugLog = (...args) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Helper for warnings that should still show in production
const debugWarn = (...args) => {
  if (DEBUG_MODE) {
    console.warn(...args);
  } else if (args[0] && args[0].includes('critical')) {
    // Allow critical warnings to show even in production
    console.warn(...args);
  }
};

// Helper for errors that should always show
const logError = (...args) => {
  console.error(...args);
};

/**
 * CollageImagesStep - The second step of the collage creation process
 * Renders a preview of the final collage layout using OffscreenCanvas
 */
const CollageImagesStep = ({
  selectedImages,
  addImage,
  removeImage,
  updateImage,
  clearImages,
  panelCount,
  handleBack, // Currently unused, but keep for potential future use
  handleNext, // Used for the main 'Create Collage' action
  selectedTemplate,
  selectedAspectRatio,
  borderThickness,
  borderColor,
  borderThicknessOptions,
  panelImageMapping,
  updatePanelImageMapping
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [renderedImage, setRenderedImage] = useState(null);
  // Fallback canvas reference for browsers that don't support OffscreenCanvas
  const canvasRef = useRef(null);
  // Store panel regions for click detection
  const [panelRegions, setPanelRegions] = useState([]);
  // Track initial load state
  const [hasInitialRender, setHasInitialRender] = useState(false);

  // --- State for Modals ---
  const [uploadOrCropDialogOpen, setUploadOrCropDialogOpen] = useState(false);
  const [cropModalOpen, setCropModalOpen] = useState(false);
  const [currentPanelToEdit, setCurrentPanelToEdit] = useState(null); // Stores the { id, x, y, width, height } of the panel being edited
  const [imageToCrop, setImageToCrop] = useState(null); // Stores the base64 source for the cropper
  const [panelAspectRatio, setPanelAspectRatio] = useState(1); // Aspect ratio for the cropping tool


  // --- Modified Click Handler ---
  const handlePreviewClick = (event) => {
    debugLog("Preview image clicked");

    const image = event.currentTarget;
    const rect = image.getBoundingClientRect();
    const clickX = (event.clientX - rect.left) / rect.width;
    const clickY = (event.clientY - rect.top) / rect.height;

    debugLog("Click coordinates as percentage:", { clickX, clickY });

    const { width, height } = calculateCanvasDimensions(selectedAspectRatio);
    const canvasX = clickX * width;
    const canvasY = clickY * height;

    debugLog("Canvas coordinates:", { canvasX, canvasY });
    debugLog("Available panel regions:", panelRegions);

    const clickedPanel = panelRegions.find(panel =>
      canvasX >= panel.x &&
      canvasX <= panel.x + panel.width &&
      canvasY >= panel.y &&
      canvasY <= panel.y + panel.height
    );

    if (clickedPanel) {
      debugLog(`Clicked on panel ${clickedPanel.id}`);
      setCurrentPanelToEdit(clickedPanel); // Store the clicked panel info

      // Calculate the aspect ratio of the clicked panel
      // Add a check for zero height to prevent division by zero -> default to aspect 1
      const calculatedAspectRatio = (clickedPanel.height > 0) ? (clickedPanel.width / clickedPanel.height) : 1;
      setPanelAspectRatio(calculatedAspectRatio);
      debugLog(`Panel aspect ratio: ${calculatedAspectRatio}`);


      // Check if the panel already has an image
      const imageIndex = panelImageMapping[clickedPanel.id];
      // Ensure selectedImages exists and is an array before accessing index
      const hasExistingImage = imageIndex !== undefined && Array.isArray(selectedImages) && selectedImages[imageIndex];

      if (hasExistingImage) {
        // Panel has image -> Open Upload or Crop dialog
        debugLog(`Panel ${clickedPanel.id} has image at index ${imageIndex}. Opening dialog.`);
        const imageItem = selectedImages[imageIndex];
        // Ensure we get the actual image data (could be string or object)
        const imageUrl = typeof imageItem === 'object' && imageItem !== null
          ? (imageItem.url || imageItem.imageUrl || imageItem)
          : imageItem;

        if (imageUrl && typeof imageUrl === 'string') { // Check if imageUrl is a non-empty string
            setImageToCrop(imageUrl); // Set the image source for the cropper
            setUploadOrCropDialogOpen(true);
        } else {
            debugWarn(`Could not get valid image URL for index ${imageIndex}. Triggering upload. ImageItem:`, imageItem);
            triggerImageUpload(clickedPanel); // Fallback to upload if URL is bad
        }
      } else {
        // Panel is empty -> Trigger upload directly
        debugLog(`Panel ${clickedPanel.id} is empty. Triggering upload.`);
        triggerImageUpload(clickedPanel);
      }
    } else {
      debugLog("No panel was clicked");
    }
  };

  // --- Function to trigger the actual file input ---
  const triggerImageUpload = (panel) => {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.onchange = (e) => {
      if (e.target.files && e.target.files[0]) {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
          const base64Image = event.target.result;

          // Check if updating existing or adding new
          const existingMappingIndex = panelImageMapping[panel.id];
          const isReplacingImage = existingMappingIndex !== undefined;

          const updatedMapping = {...panelImageMapping};

          if (isReplacingImage) {
            // Update existing image using the updateImage prop function
            updateImage(existingMappingIndex, base64Image);
          } else {
            // Add new image using addImage prop function
            const newIndex = Array.isArray(selectedImages) ? selectedImages.length : 0; // Safely get length
            addImage(base64Image); // Add to parent state
            // Ensure panel.id is valid before updating mapping
            if (panel.id !== undefined && panel.id !== null) {
                updatePanelImageMapping({ ...updatedMapping, [panel.id]: newIndex }); // Update mapping in parent state
            } else {
                logError("Panel ID is undefined, cannot update mapping for new image.");
            }
          }
        };
        reader.readAsDataURL(file);
      }
    };
    fileInput.click();
  };

  // --- Handlers for UploadOrCropDialog ---
  const handleUploadNewRequest = () => {
    if (currentPanelToEdit) {
      triggerImageUpload(currentPanelToEdit);
    }
  };

  const handleCropExistingRequest = () => {
    if (currentPanelToEdit && imageToCrop) {
      setCropModalOpen(true);
    } else {
        debugWarn("Cannot crop: Panel or image source missing.");
    }
  };

  // --- Handler for Crop Completion ---
  const handleCropComplete = (croppedDataUrl) => {
    if (!currentPanelToEdit) {
      logError("Cannot complete crop: No panel selected.");
      return;
    }

    const imageIndex = panelImageMapping[currentPanelToEdit.id];
    if (imageIndex === undefined) {
      logError("Cannot complete crop: Panel has no associated image index.");
      return;
    }

    debugLog(`Cropping complete for panel ${currentPanelToEdit.id}. Updating image index ${imageIndex}.`);
    updateImage(imageIndex, croppedDataUrl); // Update the image in the main state

    // Close the modal
    setCropModalOpen(false);
    setCurrentPanelToEdit(null);
    setImageToCrop(null);
  };

  // Function to clear image assignment for a panel (Keep this logic)
  const clearPanelImage = (panelId) => {
      const imageIndex = panelImageMapping[panelId];
      if (imageIndex !== undefined) {
          if (DEBUG_MODE) console.log(`Clearing image for panel ${panelId} (image index: ${imageIndex})`);
          const newMapping = { ...panelImageMapping };
          delete newMapping[panelId];
          updatePanelImageMapping(newMapping);

          const isImageUsedElsewhere = Object.values(newMapping).includes(imageIndex);
          if (!isImageUsedElsewhere) {
              if (DEBUG_MODE) console.log(`Removing image at index ${imageIndex} as it's not used elsewhere`);
              removeImage(imageIndex);
          }
      }
  };


  // --- Updated useEffect for Rendering ---
  /* eslint-disable consistent-return */
  useEffect(() => {
    // Add checks for required props
    if (!selectedTemplate || !selectedAspectRatio || !borderThicknessOptions) {
      debugWarn("Skipping render: Missing required props (template, aspect ratio, or border options)");
      return;
    }

    console.log(`[STEP DEBUG] CollageImagesStep rendering triggered. Deps:`, {
        templateId: selectedTemplate?.id, aspect: selectedAspectRatio, count: panelCount,
        themeMode: theme.palette.mode, borderThickness, borderColor,
        imageCount: Array.isArray(selectedImages) ? selectedImages.length : 0, // Safe length check
        mappingKeys: Object.keys(panelImageMapping || {}), // Safe key check
        hasInitialRender
    });

    let borderThicknessValue = 4; // Default
    if (borderThicknessOptions && borderThickness) {
        const option = borderThicknessOptions.find(opt => typeof opt.label === 'string' && opt.label.toLowerCase() === borderThickness.toLowerCase());
        if (option) borderThicknessValue = option.value;
        else console.log(`[STEP DEBUG] No matching option found for borderThickness: ${borderThickness}`);
    } else {
      console.log(`[STEP DEBUG] Using default borderThicknessValue: ${borderThicknessValue}`);
    }

    const adjustedBorderThickness = adjustForPanelCount(borderThicknessValue, panelCount);
    console.log(`[STEP DEBUG] Adjusted border thickness for panelCount ${panelCount}: ${adjustedBorderThickness} (original: ${borderThicknessValue})`);

    const initialDelay = hasInitialRender ? 0 : 50;

    const timer = setTimeout(() => {
      try {
        console.log(`[STEP DEBUG] Calling renderTemplateToCanvas with borderThickness: ${adjustedBorderThickness}, panelCount: ${panelCount}, borderColor: ${borderColor}`);
        renderTemplateToCanvas({
          selectedTemplate,
          selectedAspectRatio,
          panelCount,
          theme,
          canvasRef,
          setPanelRegions, // This function receives the calculated regions
          setRenderedImage,
          borderThickness: adjustedBorderThickness,
          borderColor,
          selectedImages, // Pass the latest images from props
          panelImageMapping // Pass the latest mapping from props
        });

        if (!hasInitialRender) {
          setHasInitialRender(true);
        }
      } catch (error) {
        console.error("Error rendering template:", error);
        // Optionally set an error state or display a message
      }
    }, initialDelay);

    return () => clearTimeout(timer);
  }, [
    selectedTemplate,
    selectedAspectRatio,
    panelCount,
    theme.palette.mode,
    borderThickness,
    borderColor,
    selectedImages,
    panelImageMapping,
    hasInitialRender,
    borderThicknessOptions,
    // Added missing dependencies based on usage inside the effect
    theme, setRenderedImage
  ]);
  /* eslint-enable consistent-return */

  // Clean up resources when component unmounts
  useEffect(() => {
    return () => {
      if (renderedImage && renderedImage.startsWith('blob:')) {
        URL.revokeObjectURL(renderedImage);
      }
    };
  }, [renderedImage]);

  return (
    <Box sx={{ my: isMobile ? 0 : 0.5 }}>
      {/* Layout Preview */}
      <Paper
        elevation={1}
        sx={{
          p: isMobile ? 1 : 2,
          mb: isMobile ? 1 : 2,
          backgroundColor: theme.palette.background.paper,
          borderRadius: 2,
          textAlign: 'center',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          position: 'relative'
        }}
      >
        {!isMobile && (
          <Typography variant="subtitle2" color="text.secondary" gutterBottom sx={{ mb: 1 }}>
            Click a panel to upload or crop image
          </Typography>
        )}

        {renderedImage ? (
          <>
            <Box
              component="img"
              src={renderedImage}
              alt="Collage Layout Preview"
              onClick={handlePreviewClick} // Use the modified handler
              sx={{
                maxWidth: '100%',
                maxHeight: isMobile ? 300 : 350,
                objectFit: 'contain',
                borderRadius: 1,
                cursor: 'pointer',
                margin: '0 auto',
                display: 'block',
                border: `1px solid ${theme.palette.divider}` // Add subtle border
              }}
            />
          </>
        ) : (
          <Box
            sx={{
              height: 180,
              width: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: theme.palette.action.hover,
              borderRadius: 1,
            }}
          >
            <Typography variant="body2" color="text.secondary">
              Generating layout preview...
            </Typography>
          </Box>
        )}
      </Paper>

      {/* Hidden canvas fallback */}
      <canvas ref={canvasRef} style={{ display: "none" }} />

      {/* --- Modals --- */}
      {typeof UploadOrCropDialog === 'function' ? (
        <UploadOrCropDialog
          open={uploadOrCropDialogOpen}
          onClose={() => setUploadOrCropDialogOpen(false)}
          onUploadNew={handleUploadNewRequest}
          onCropExisting={handleCropExistingRequest}
        />
      ) : (
         DEBUG_MODE && console.error("UploadOrCropDialog is not a function, import failed?")
      )}

      {typeof ImageCropModal === 'function' ? (
        <ImageCropModal
          open={cropModalOpen}
          onClose={() => setCropModalOpen(false)}
          imageSrc={imageToCrop}
          aspectRatio={panelAspectRatio} // Use the calculated panel aspect ratio
          onCropComplete={handleCropComplete}
        />
       ) : (
         DEBUG_MODE && console.error("ImageCropModal is not a function, import failed?")
       )}
    </Box>
  );
};

export default CollageImagesStep;


// Add defaultProps to ensure the component has fallback values
CollageImagesStep.defaultProps = {
  selectedImages: [],
  panelCount: 2,
  selectedAspectRatio: 'portrait',
  borderThickness: 'medium',
  borderThicknessOptions: [
    { label: "None", value: 0 },
    { label: "Thin", value: 6 },
    { label: "Medium", value: 16 },
    { label: "Thicc", value: 40 },
    { label: "Thiccer", value: 80 },
    { label: "XTRA THICC", value: 120 }
  ],
  panelImageMapping: {},
  addImage: () => {},
  removeImage: () => {},
  updateImage: () => {},
  updatePanelImageMapping: () => {},
};

===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/ImageCropModal.js =====

import React, { useState, useRef, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  CircularProgress,
  Typography,
  useMediaQuery
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import ReactCrop, {
  centerCrop,
  makeAspectCrop,
  convertToPixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';

// Helper to get initial crop based on aspect ratio
function centerAspectCrop(mediaWidth, mediaHeight, aspect) {
  return centerCrop(
    makeAspectCrop(
      {
        unit: '%',
        width: 90, // Start with 90% width crop centered
      },
      aspect,
      mediaWidth,
      mediaHeight,
    ),
    mediaWidth,
    mediaHeight,
  );
}

export default function ImageCropModal({
  open,
  onClose,
  imageSrc,
  aspectRatio, // Expecting a number (width / height)
  onCropComplete,
}) {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [crop, setCrop] = useState();
  const [completedCrop, setCompletedCrop] = useState(null);
  const [imgLoadError, setImgLoadError] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const imgRef = useRef(null);
  const previewCanvasRef = useRef(null); // For showing a preview, if desired

  useEffect(() => {
    // Reset state when dialog opens or image changes
    if (open) {
      setCrop(undefined); // Reset crop area
      setCompletedCrop(null);
      setImgLoadError(false);
      setIsProcessing(false);
    }
  }, [open, imageSrc]);

  const onImageLoad = (e) => {
    setImgLoadError(false);
    const { width, height } = e.currentTarget;
    // Set initial crop area centered with the correct aspect ratio
    if (aspectRatio) {
        setCrop(centerAspectCrop(width, height, aspectRatio));
        // Also set completed crop initially to enable cropping immediately
        setCompletedCrop(convertToPixelCrop(
            centerAspectCrop(width, height, aspectRatio),
            width,
            height
        ));
    }
  };

  const onImageError = () => {
    setImgLoadError(true);
    console.error("Error loading image for cropping.");
  };

  const handleCrop = async () => {
    if (!completedCrop || !imgRef.current || isProcessing) {
      console.warn('Crop data or image ref missing, or already processing.');
      return;
    }

    setIsProcessing(true);
    const image = imgRef.current;
    const canvas = document.createElement('canvas'); // Use an offscreen canvas
    const scaleX = image.naturalWidth / image.width;
    const scaleY = image.naturalHeight / image.height;

    canvas.width = Math.floor(completedCrop.width * scaleX);
    canvas.height = Math.floor(completedCrop.height * scaleY);

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      throw new Error('No 2d context');
    }

    const pixelRatio = window.devicePixelRatio || 1;

    ctx.scale(pixelRatio, pixelRatio);
    ctx.imageSmoothingQuality = 'high';

    const cropX = completedCrop.x * scaleX;
    const cropY = completedCrop.y * scaleY;

    // Move canvas origin to the center of the canvas to rotate/scale around center.
    ctx.translate(canvas.width / 2 / pixelRatio, canvas.height / 2 / pixelRatio);
    // Uncomment below if rotation/scale is needed
    // ctx.rotate(rotate * Math.PI / 180)
    // ctx.scale(scale, scale)
    ctx.translate(-canvas.width / 2 / pixelRatio, -canvas.height / 2 / pixelRatio);

    ctx.drawImage(
      image,
      cropX,
      cropY,
      completedCrop.width * scaleX,
      completedCrop.height * scaleY,
      0,
      0,
      canvas.width / pixelRatio,
      canvas.height / pixelRatio,
    );

    // Convert canvas to base64
    canvas.toBlob((blob) => {
        if (!blob) {
            console.error('Canvas is empty');
            setIsProcessing(false);
            return;
          }
        const reader = new FileReader();
        reader.onloadend = () => {
            const base64data = reader.result;
            onCropComplete(base64data);
            setIsProcessing(false);
            onClose(); // Close modal after successful crop
        };
        reader.readAsDataURL(blob);
    }, 'image/png');

  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="md"
      fullWidth
      fullScreen={isMobile}
      PaperProps={{ sx: { height: isMobile ? '100%' : '90vh' } }}
    >
      <DialogTitle>Crop Image</DialogTitle>
      <DialogContent dividers sx={{ display: 'flex', flexDirection: 'column', p: isMobile ? 1 : 2 }}>
        {imgLoadError && (
          <Typography color="error" align="center" sx={{ my: 2 }}>
            Failed to load image. Please try a different one.
          </Typography>
        )}
        {!imgLoadError && imageSrc && (
          <Box sx={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'center', overflow: 'hidden', background: theme.palette.mode === 'dark' ? '#222' : '#eee' }}>
            <ReactCrop
              crop={crop}
              onChange={(_, percentCrop) => setCrop(percentCrop)}
              onComplete={(c) => setCompletedCrop(c)}
              aspect={aspectRatio}
              // minWidth={100} // Optional: set min crop dimensions
              // minHeight={100}
            >
              <img
                ref={imgRef}
                alt="Crop me"
                src={imageSrc}
                style={{ maxHeight: '70vh', maxWidth: '100%', objectFit: 'contain' }}
                onLoad={onImageLoad}
                onError={onImageError}
              />
            </ReactCrop>
          </Box>
        )}
        {/* Optional Preview Canvas
        {!!completedCrop && (
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
            <canvas
              ref={previewCanvasRef}
              style={{
                border: '1px solid black',
                objectFit: 'contain',
                width: completedCrop.width,
                height: completedCrop.height,
                maxWidth: 150, // Limit preview size
                maxHeight: 150 * (1 / aspectRatio)
              }}
            />
          </Box>
        )} */}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} color="secondary" disabled={isProcessing}>
          Cancel
        </Button>
        <Button
          onClick={handleCrop}
          color="primary"
          variant="contained"
          disabled={!completedCrop || imgLoadError || isProcessing}
        >
          {isProcessing ? <CircularProgress size={24} color="inherit" /> : 'Crop'}
        </Button>
      </DialogActions>
    </Dialog>
  );
}


===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/UploadOrCropDialog.js =====

import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography
} from '@mui/material';
import { UploadFile, Crop } from '@mui/icons-material';

export default function UploadOrCropDialog({
  open,
  onClose,
  onUploadNew,
  onCropExisting,
}) {
  const handleUpload = () => {
    onUploadNew();
    onClose();
  };

  const handleCrop = () => {
    onCropExisting();
    onClose();
  };

  return (
    <Dialog open={open} onClose={onClose} aria-labelledby="upload-or-crop-dialog-title">
      <DialogTitle id="upload-or-crop-dialog-title">Update Panel Image</DialogTitle>
      <DialogContent>
        <Typography>
          This panel already has an image. Would you like to upload a new image or crop the existing one?
        </Typography>
      </DialogContent>
      <DialogActions sx={{ justifyContent: 'space-around', p: 2 }}>
        <Button
          onClick={handleUpload}
          color="primary"
          variant="outlined"
          startIcon={<UploadFile />}
          sx={{ flexGrow: 1, mx: 1 }}
        >
          Upload New
        </Button>
        <Button
          onClick={handleCrop}
          color="secondary"
          variant="outlined"
          startIcon={<Crop />}
          sx={{ flexGrow: 1, mx: 1 }}
        >
          Crop Existing
        </Button>
      </DialogActions>
    </Dialog>
  );
}

===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/utils/FabricImageEditor.js =====

/**
 * FabricImageEditor.js
 * Utilities for handling image editing with Fabric.js for the collage panel images
 */
import { fabric } from 'fabric';

/**
 * Initialize a new Fabric.js canvas
 * @param {HTMLCanvasElement} canvasElement - The canvas DOM element to use
 * @returns {fabric.Canvas} - The initialized Fabric.js canvas instance
 */
export const initCanvas = (canvasElement) => {
  // Create Fabric canvas with selection disabled (we only want to manipulate the image)
  const canvas = new fabric.Canvas(canvasElement, {
    preserveObjectStacking: true,
    selection: false,
    uniformScaling: true,
    imageSmoothingEnabled: true
  });
  
  // Set reasonable dimensions
  canvas.setWidth(600);
  canvas.setHeight(600);
  
  return canvas;
};

/**
 * Load an image to the canvas with proper positioning and sizing
 * @param {fabric.Canvas} canvas - The Fabric.js canvas instance
 * @param {string} imageUrl - URL of the image to load
 * @param {number} aspectRatio - Target aspect ratio (width/height)
 * @returns {Promise} - Promise that resolves when the image is loaded
 */
export const loadImageToCanvas = (canvas, imageUrl, aspectRatio) => {
  return new Promise((resolve, reject) => {
    if (!canvas) {
      reject(new Error("Canvas is not initialized"));
      return;
    }
    
    // Clear existing canvas content
    canvas.clear();
    
    // Set canvas dimensions based on aspect ratio
    let canvasWidth = 600;
    let canvasHeight = Math.round(canvasWidth / aspectRatio);
    
    // If height would be too tall, adjust width instead
    if (canvasHeight > 600) {
      canvasHeight = 600;
      canvasWidth = Math.round(canvasHeight * aspectRatio);
    }
    
    canvas.setWidth(canvasWidth);
    canvas.setHeight(canvasHeight);
    
    // Create crop guide (visible rectangle that shows the crop area)
    const cropGuide = new fabric.Rect({
      width: canvasWidth,
      height: canvasHeight,
      fill: 'transparent',
      stroke: '#2196F3',
      strokeWidth: 2,
      strokeDashArray: [5, 5],
      selectable: false,
      evented: false,
      originX: 'center',
      originY: 'center',
      left: canvasWidth / 2,
      right: canvasHeight / 2
    });
    
    // Add the crop guide first
    canvas.add(cropGuide);
    
    // Create a timeout in case the image load takes too long
    const timeoutId = setTimeout(() => {
      // Don't reject, but log a warning
    }, 10000); // 10 second timeout
    
    // Load the image with error handling
    try {
      fabric.Image.fromURL(
        imageUrl,
        (img) => {
          clearTimeout(timeoutId);
          
          if (!img) {
            reject(new Error("Failed to create fabric image"));
            return;
          }
          
          // Calculate scale to fit image within canvas
          const imgWidth = img.width;
          const imgHeight = img.height;
          
          if (imgWidth === 0 || imgHeight === 0) {
            reject(new Error("Invalid image dimensions"));
            return;
          }
          
          // Calculate scale to fit image within canvas
          const scaleX = canvasWidth / imgWidth;
          const scaleY = canvasHeight / imgHeight;
          const scale = Math.max(scaleX, scaleY) * 1.1; // Make it slightly larger than needed
          
          // Store original scale for future reference
          img._originalScale = scale;
          
          // Apply scale and center the image
          img.set({
            scaleX: scale,
            scaleY: scale,
            originX: 'center',
            originY: 'center',
            left: canvasWidth / 2,
            top: canvasHeight / 2,
            lockUniScaling: true, // Keep aspect ratio when scaling
            centeredScaling: true,
            centeredRotation: true,
          });
          
          // Make this the only selectable object
          img.setControlsVisibility({
            mt: false, 
            mb: false, 
            ml: false, 
            mr: false,
            bl: false,
            br: false,
            tl: false,
            tr: false,
            mtr: true // Keep rotation control
          });
          
          // Add image to canvas (after crop guide, so it appears on top)
          canvas.add(img);
          canvas.setActiveObject(img);
          
          // Center and refresh canvas
          canvas.renderAll();
          
          resolve(img);
        },
        (err) => {
          clearTimeout(timeoutId);
          reject(err);
        },
        {
          crossOrigin: 'Anonymous'
        }
      );
    } catch (err) {
      clearTimeout(timeoutId);
      reject(err);
    }
  });
};

/**
 * Zoom the canvas image
 * @param {fabric.Canvas} canvas - The Fabric.js canvas
 * @param {number} zoomFactor - Zoom factor to apply (1 = 100%)
 */
export const zoomCanvas = (canvas, zoomFactor) => {
  if (!canvas) {
    return;
  }
  
  const img = canvas.getActiveObject();
  if (!img || img.type !== 'image') {
    return;
  }
  
  // Get original scale
  const originalScale = img._originalScale || 1;
  
  // Apply zoom
  img.set({
    scaleX: originalScale * zoomFactor,
    scaleY: originalScale * zoomFactor
  });
  
  // Update canvas
  img.setCoords();
  canvas.renderAll();
};

/**
 * Enable image zoom with mouse wheel
 * @param {fabric.Canvas} canvas - The Fabric.js canvas
 */
export const enableImageZoom = (canvas) => {
  if (!canvas) {
    return;
  }
  
  canvas.on('mouse:wheel', (opt) => {
    const img = canvas.getActiveObject();
    if (!img || img.type !== 'image') return;
    
    const delta = opt.e.deltaY;
    let zoom = img.scaleX;
    
    // Determine zoom direction and apply a zoom factor
    if (delta > 0) {
      zoom = Math.max(0.5, zoom - 0.05); // Zoom out
    } else {
      zoom = Math.min(3, zoom + 0.05); // Zoom in
    }
    
    // Apply the new scale
    img.set({
      scaleX: zoom,
      scaleY: zoom
    });
    
    // Update canvas
    img.setCoords();
    canvas.renderAll();
    
    // Prevent page scrolling
    opt.e.preventDefault();
    opt.e.stopPropagation();
  });
};

/**
 * Rotate the image on the canvas
 * @param {fabric.Canvas} canvas - The Fabric.js canvas
 * @param {number} angleIncrement - Angle increment to rotate by
 */
export const rotateImage = (canvas, angleIncrement) => {
  const img = canvas.getActiveObject();
  if (!img || img.type !== 'image') return;
  
  // Get current angle
  const currentAngle = img.angle || 0;
  
  // Apply new angle
  img.set({ angle: currentAngle + angleIncrement });
  
  // Update canvas
  img.setCoords();
  canvas.renderAll();
};

/**
 * Add keyboard shortcuts for image manipulation
 * @param {fabric.Canvas} canvas - The Fabric.js canvas
 */
export const addKeyboardShortcuts = (canvas) => {
  const handler = (e) => {
    // Only process if the canvas is visible and has an active object
    const img = canvas.getActiveObject();
    if (!img || img.type !== 'image') return;
    
    // Skip if user is in an input field
    if (e.target instanceof HTMLInputElement || 
        e.target instanceof HTMLTextAreaElement) {
      return;
    }
    
    const moveAmount = 10; // Pixels to move per arrow key press
    let handled = true;
    
    switch (e.key) {
      case 'ArrowUp':
        img.set({ top: img.top - moveAmount });
        break;
      case 'ArrowDown':
        img.set({ top: img.top + moveAmount });
        break;
      case 'ArrowLeft':
        img.set({ left: img.left - moveAmount });
        break;
      case 'ArrowRight':
        img.set({ left: img.left + moveAmount });
        break;
      case 'r':
        rotateImage(canvas, 90); // Rotate right
        break;
      case 'R':
        rotateImage(canvas, -90); // Rotate left
        break;
      case '0':
        resetImage(canvas); // Reset image
        break;
      case '+':
      case '=':
        zoomCanvas(canvas, (img.scaleX + 0.1) / (img._originalScale || 1)); // Zoom in
        break;
      case '-':
        zoomCanvas(canvas, (img.scaleX - 0.1) / (img._originalScale || 1)); // Zoom out
        break;
      default:
        handled = false;
        break;
    }
    
    if (handled) {
      e.preventDefault();
      img.setCoords();
      canvas.renderAll();
    }
  };
  
  // Add the keyboard event listener
  document.addEventListener('keydown', handler);
  
  // Return a cleanup function to remove the listener
  canvas._keyboardHandler = handler;
  
  // Cleanup function for removing event listener
  return () => {
    document.removeEventListener('keydown', canvas._keyboardHandler);
  };
};

/**
 * Reset the image to its original position and scale
 * @param {fabric.Canvas} canvas - The Fabric.js canvas
 */
export const resetImage = (canvas) => {
  const img = canvas.getActiveObject();
  if (!img || img.type !== 'image') return;
  
  // Reset image position to center
  const canvasWidth = canvas.getWidth();
  const canvasHeight = canvas.getHeight();
  
  // Calculate scale to fit image within canvas
  const imgWidth = img.width;
  const imgHeight = img.height;
  const scaleX = canvasWidth / imgWidth;
  const scaleY = canvasHeight / imgHeight;
  const scale = Math.max(scaleX, scaleY) * 1.1; // Make it slightly larger than needed
  
  // Store original scale for future reference
  img._originalScale = scale;
  
  // Reset all properties
  img.set({
    left: canvasWidth / 2,
    top: canvasHeight / 2,
    scaleX: scale,
    scaleY: scale,
    angle: 0
  });
  
  // Update canvas
  img.setCoords();
  canvas.renderAll();
};

/**
 * Generate a cropped image from the canvas based on the aspect ratio
 * @param {fabric.Canvas} canvas - The Fabric.js canvas instance
 * @param {number} aspectRatio - Aspect ratio of the panel
 * @returns {string} - Data URL of the cropped image
 */
export const generateCroppedImage = (canvas, aspectRatio) => {
  return new Promise((resolve, reject) => {
    try {
      console.log('Starting to generate cropped image with aspect ratio:', aspectRatio);
      const objects = canvas.getObjects();
      
      if (objects.length === 0) {
        reject(new Error("No objects found on canvas"));
        return;
      }
      
      // Find the image object
      const img = objects.find(obj => obj.type === 'image');
      if (!img) {
        reject(new Error("No image found on canvas"));
        return;
      }
      
      // Make sure the image is the active object
      canvas.setActiveObject(img);
      
      // Create a temporary canvas to render the cropped image
      const tempCanvas = document.createElement('canvas');
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      console.log('Canvas dimensions:', { canvasWidth, canvasHeight });
      
      // Set temporary canvas dimensions
      tempCanvas.width = canvasWidth;
      tempCanvas.height = canvasHeight;
      
      // Create temporary fabric canvas
      const tempFabricCanvas = new fabric.StaticCanvas(tempCanvas);
      tempFabricCanvas.setWidth(canvasWidth);
      tempFabricCanvas.setHeight(canvasHeight);
      
      // Clone the image for rendering
      img.clone(clonedImg => {
        // Add only the image to the temporary canvas
        tempFabricCanvas.add(clonedImg);
        tempFabricCanvas.renderAll();
        
        // Convert to data URL
        const dataUrl = tempFabricCanvas.toDataURL({
          format: 'png',
          quality: 1,
          width: canvasWidth,
          height: canvasHeight
        });
        
        console.log('Generated data URL successfully');
        
        // Dispose temporary canvas
        tempFabricCanvas.dispose();
        
        resolve(dataUrl);
      });
    } catch (err) {
      console.error('Error generating cropped image:', err);
      reject(err);
    }
  });
};

// Export all functions
export default {
  initCanvas,
  loadImageToCanvas,
  zoomCanvas,
  rotateImage,
  resetImage,
  generateCroppedImage,
  enableImageZoom,
  addKeyboardShortcuts
}; 

===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/components/PanelImageEditor.js =====

import React, { useEffect, useRef, useState, useCallback } from 'react';
import { useTheme } from '@mui/material/styles';
import {
  Box,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  Paper,
  Slider,
  Stack,
  Tooltip,
  Typography,
  CircularProgress
} from '@mui/material';
import {
  ZoomIn,
  ZoomOut,
  RotateLeft,
  RotateRight,
  Replay,
  AspectRatio,
  Check,
  Close,
  Save
} from '@mui/icons-material';

// Import fabric directly for our custom blob handling
import { fabric } from 'fabric';

// Import only the functions that are actually exported from FabricImageEditor
import {
  initCanvas,
  loadImageToCanvas,
  zoomCanvas,
  rotateImage,
  resetImage,
  generateCroppedImage,
  enableImageZoom,
  addKeyboardShortcuts
} from '../utils/FabricImageEditor';

/**
 * PanelImageEditor - A component for editing images for collage panels
 * 
 * @param {Object} props - Component props
 * @param {boolean} props.open - Whether the editor dialog is open
 * @param {function} props.onClose - Function to call when closing the dialog
 * @param {string} props.imageUrl - URL of the image to edit
 * @param {number} props.panelId - ID of the panel being edited
 * @param {number} props.aspectRatio - Aspect ratio of the panel
 * @param {function} props.onSave - Function to call when saving the edited image
 */
const PanelImageEditor = ({ 
  open, 
  onClose, 
  imageUrl, 
  panelId = null, 
  aspectRatio = 1, 
  onSave 
}) => {
  const theme = useTheme();
  const canvasRef = useRef(null);
  const fabricCanvasRef = useRef(null);
  const loadTimeoutRef = useRef(null);
  const isMountedRef = useRef(true); // Track if component is mounted
  const [zoom, setZoom] = useState(100);
  const [rotation, setRotation] = useState(0);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState(null);
  // Add a counter state to force re-renders when needed
  const [renderCounter, setRenderCounter] = useState(0);
  
  // Create a force re-render function
  const forceUpdate = useCallback(() => {
    if (isMountedRef.current) {
      setRenderCounter(prev => prev + 1);
    }
  }, []);
  
  // Set isMounted to false when component unmounts
  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  
  // Safe state update functions
  const safeSetImageLoaded = useCallback((value) => {
    if (isMountedRef.current) {
      setImageLoaded(value);
    }
  }, []);
  
  const safeSetError = useCallback((value) => {
    if (isMountedRef.current) {
      setError(value);
    }
  }, []);
  
  // Initialize the Fabric.js canvas when the component mounts or dialog opens
  useEffect(() => {
    console.log('Canvas initialization effect triggered', { open, canvasRef: !!canvasRef.current });
    
    if (open && canvasRef.current) {
      try {
        // Dispose of previous canvas if it exists
        if (fabricCanvasRef.current) {
          fabricCanvasRef.current.dispose();
          fabricCanvasRef.current = null;
        }
        
        // Create a new canvas
        console.log('Initializing Fabric canvas');
        fabricCanvasRef.current = initCanvas(canvasRef.current);
        console.log('Canvas initialized successfully', { fabricCanvas: !!fabricCanvasRef.current });
        
        // Set canvas as ready
        setCanvasReady(true);
        
        // Force a re-render after canvas initialization
        forceUpdate();
        
        // If dialog is open but no image URL is provided, show an error
        if (!imageUrl) {
          console.warn('Dialog opened but no image URL provided');
          safeSetError("No image provided");
          safeSetImageLoaded(true); // Set to true to avoid loading state
        } else {
          // Now that canvas is initialized, trigger image loading
          console.log('Canvas ready, will load image:', imageUrl);
          // We'll handle the actual loading in the image loading effect
        }
      } catch (err) {
        console.error('Error initializing canvas:', err);
        safeSetError("Failed to initialize image editor");
        setCanvasReady(false);
      }
    } else {
      // If dialog is closed or canvas ref is not available, set canvas as not ready
      setCanvasReady(false);
    }
    
    // Clean up
    return () => {
      if (fabricCanvasRef.current) {
        fabricCanvasRef.current.dispose();
        fabricCanvasRef.current = null;
      }
      
      if (loadTimeoutRef.current) {
        clearTimeout(loadTimeoutRef.current);
        loadTimeoutRef.current = null;
      }
      
      safeSetImageLoaded(false);
      setCanvasReady(false);
    };
  }, [open, forceUpdate, imageUrl, safeSetError, safeSetImageLoaded]);
  
  // Track when canvas is ready for image loading
  const [canvasReady, setCanvasReady] = useState(false);
  
  // Update canvasReady state when fabricCanvas is initialized
  useEffect(() => {
    const hasFabricCanvas = !!fabricCanvasRef.current;
    console.log('Checking canvas ready state:', { hasFabricCanvas });
    setCanvasReady(hasFabricCanvas);
  }, [renderCounter]);
  
  // Load image when URL changes and canvas is ready
  useEffect(() => {
    console.log('Image loading effect triggered', { 
      open, 
      hasImageUrl: !!imageUrl, 
      hasFabricCanvas: !!fabricCanvasRef.current,
      canvasReady,
      imageUrl
    });
    
    let cleanupFunction = () => {}; // Initialize with empty function
    let imageLoadTimeout = null;

    // Only proceed if dialog is open, we have an image URL, and the canvas is ready
    if (open && imageUrl && fabricCanvasRef.current && canvasReady) {
      // Check if imageUrl is a valid URL or data URL or blob URL
      const isValidUrl = (url) => {
        try {
          return url.startsWith('data:') || url.startsWith('blob:') || Boolean(new URL(url));
        } catch (e) {
          return false;
        }
      };
      
      if (!isValidUrl(imageUrl)) {
        console.error('Invalid image URL format:', imageUrl);
        safeSetError("Invalid image URL format");
        safeSetImageLoaded(true); // Set to true to avoid loading state
        // Don't return here, continue to the cleanup function
      } else {
        safeSetImageLoaded(false);
        safeSetError(null);
        
        // Set a global timeout for the entire image loading process
        imageLoadTimeout = setTimeout(() => {
          if (!imageLoaded && isMountedRef.current) {
            console.warn('Image loading timed out after 15 seconds');
            safeSetError("Image loading timed out. Please try again.");
            safeSetImageLoaded(true);
            forceUpdate();
          }
        }, 15000); // 15 second timeout for the entire process
        
        // Log the image URL being loaded
        console.log('Loading image into Fabric editor:', imageUrl);
        
        // SIMPLIFIED APPROACH: Use a single method for all URL types
        // Create a new image element
        const img = new Image();
        img.crossOrigin = 'Anonymous'; // Important for CORS
        
        img.onload = () => {
          console.log('Image loaded successfully', { 
            width: img.width, 
            height: img.height,
            imageUrl
          });
          
          try {
            // Clear the canvas
            fabricCanvasRef.current.clear();
            
            // Set canvas dimensions based on aspect ratio
            let canvasWidth = 600;
            let canvasHeight = Math.round(canvasWidth / aspectRatio);
            
            // If height would be too tall, adjust width instead
            if (canvasHeight > 600) {
              canvasHeight = 600;
              canvasWidth = Math.round(canvasHeight * aspectRatio);
            }
            
            fabricCanvasRef.current.setWidth(canvasWidth);
            fabricCanvasRef.current.setHeight(canvasHeight);
            
            // Create crop guide
            const cropGuide = new fabric.Rect({
              width: canvasWidth,
              height: canvasHeight,
              fill: 'transparent',
              stroke: '#2196F3',
              strokeWidth: 2,
              strokeDashArray: [5, 5],
              selectable: false,
              evented: false,
              originX: 'center',
              originY: 'center',
              left: canvasWidth / 2,
              top: canvasHeight / 2
            });
            
            // Add the crop guide
            fabricCanvasRef.current.add(cropGuide);
            
            // Create a fabric image from the loaded image
            const fabricImage = new fabric.Image(img);
            
            // Scale the image to fit within the canvas
            const scale = Math.min(
              canvasWidth / img.width,
              canvasHeight / img.height
            ) * 0.9; // Add a little padding
            
            fabricImage.set({
              scaleX: scale,
              scaleY: scale,
              originX: 'center',
              originY: 'center',
              left: canvasWidth / 2,
              top: canvasHeight / 2
            });
            
            // Add the image to the canvas
            fabricCanvasRef.current.add(fabricImage);
            fabricCanvasRef.current.setActiveObject(fabricImage);
            fabricCanvasRef.current.renderAll();
            
            // Update state
            console.log('Image successfully loaded into canvas');
            safeSetImageLoaded(true);
            forceUpdate();
            
            // Set up image manipulation
            try {
              // Enable zoom with mouse wheel
              enableImageZoom(fabricCanvasRef.current);
              
              // Add keyboard shortcuts
              const cleanupKeyboardShortcuts = addKeyboardShortcuts(fabricCanvasRef.current);
              
              // Listen for object modifications to update UI state
              fabricCanvasRef.current.on('object:modified', (e) => {
                if (e.target && e.target.type === 'image') {
                  setZoom(e.target.scaleX * 100 || 100);
                  setRotation(e.target.angle || 0);
                  // Force update to ensure UI reflects changes
                  forceUpdate();
                }
              });
              
              // Listen for object scaling to update zoom level
              fabricCanvasRef.current.on('object:scaling', (e) => {
                if (e.target && e.target.type === 'image') {
                  setZoom(e.target.scaleX * 100 || 100);
                }
              });
              
              // Listen for object rotating to update rotation angle
              fabricCanvasRef.current.on('object:rotating', (e) => {
                if (e.target && e.target.type === 'image') {
                  setRotation(e.target.angle || 0);
                }
              });
              
              // Update the cleanup function
              cleanupFunction = () => {
                // Clean up keyboard shortcuts
                if (typeof cleanupKeyboardShortcuts === 'function') {
                  cleanupKeyboardShortcuts();
                }
                
                if (loadTimeoutRef.current) {
                  clearTimeout(loadTimeoutRef.current);
                  loadTimeoutRef.current = null;
                }
              };
            } catch (err) {
              console.error('Error setting up image manipulation:', err);
              safeSetImageLoaded(true);
              forceUpdate();
            }
          } catch (err) {
            console.error('Error creating fabric image:', err);
            safeSetError("Failed to create image. Please try again.");
            safeSetImageLoaded(true);
            forceUpdate();
          }
        };
        
        img.onerror = (err) => {
          console.error('Error loading image:', err);
          safeSetError("Failed to load image. The file may be corrupted or inaccessible.");
          safeSetImageLoaded(true);
          forceUpdate();
        };
        
        // Set a backup timeout in case onload doesn't trigger
        loadTimeoutRef.current = setTimeout(() => {
          if (!imageLoaded && isMountedRef.current) {
            console.log('Backup timeout triggered - forcing image loaded state');
            safeSetImageLoaded(true);
            forceUpdate();
          }
        }, 5000); // 5 second backup
        
        console.log('Setting image src to:', imageUrl);
        img.src = imageUrl;
      }
    }

    // Always return a consistent cleanup function
    return () => {
      if (typeof cleanupFunction === 'function') {
        cleanupFunction();
      }
      
      if (imageLoadTimeout) {
        clearTimeout(imageLoadTimeout);
      }
      
      if (loadTimeoutRef.current) {
        clearTimeout(loadTimeoutRef.current);
        loadTimeoutRef.current = null;
      }
    };
  }, [imageUrl, aspectRatio, open, forceUpdate, safeSetImageLoaded, safeSetError, imageLoaded, canvasReady]);
  
  // Add a check to verify image is loaded after component renders
  useEffect(() => {
    console.log('Image verification effect triggered', { 
      open, 
      hasFabricCanvas: !!fabricCanvasRef.current,
      imageLoaded
    });
    
    if (open && fabricCanvasRef.current) {
      // Check if canvas has objects but UI doesn't reflect that
      const hasObjects = fabricCanvasRef.current.getObjects().length > 0;
      const hasImage = fabricCanvasRef.current.getObjects().some(obj => obj.type === 'image');
      
      console.log('Canvas object check', { hasObjects, hasImage, imageLoaded });
      
      if (hasImage && !imageLoaded) {
        console.log('Image found in canvas but not marked as loaded - updating state');
        safeSetImageLoaded(true);
      }
    }
  }, [open, imageLoaded, renderCounter, safeSetImageLoaded]);
  
  // Add a debug effect to log when all conditions are met for image loading
  useEffect(() => {
    if (open && imageUrl && canvasReady && fabricCanvasRef.current) {
      console.log('All conditions met for image loading', {
        open,
        hasImageUrl: !!imageUrl,
        canvasReady,
        hasFabricCanvas: !!fabricCanvasRef.current
      });
    }
  }, [open, imageUrl, canvasReady]);
  
  // Handle zoom changes
  const handleZoomChange = (newZoom) => {
    setZoom(newZoom);
    if (fabricCanvasRef.current) {
      zoomCanvas(fabricCanvasRef.current, newZoom / 100);
    }
  };
  
  // Handle rotation
  const handleRotate = (angle) => {
    const newRotation = (rotation + angle) % 360;
    setRotation(newRotation);
    if (fabricCanvasRef.current) {
      rotateImage(fabricCanvasRef.current, angle);
    }
  };
  
  // Handle reset
  const handleReset = () => {
    setZoom(100);
    setRotation(0);
    if (fabricCanvasRef.current) {
      resetImage(fabricCanvasRef.current);
    }
  };
  
  // Handle save
  const handleSave = async () => {
    if (!fabricCanvasRef.current || !imageLoaded) {
      console.error('Cannot save: Canvas not initialized or image not loaded');
      return;
    }
    
    setIsSaving(true);
    
    try {
      console.log('Generating cropped image...', { panelId, aspectRatio });
      
      // Get the active object (should be the image)
      const activeObject = fabricCanvasRef.current.getActiveObject();
      const image = fabricCanvasRef.current.getObjects().find(obj => obj.type === 'image');
      
      if (!image) {
        throw new Error('No image found on canvas');
      }
      
      // Make sure the image is the active object
      if (!activeObject || activeObject.type !== 'image') {
        console.log('Setting image as active object before saving');
        fabricCanvasRef.current.setActiveObject(image);
        fabricCanvasRef.current.renderAll();
      }
      
      // Use the utility function to generate the cropped image
      const croppedImageUrl = await generateCroppedImage(
        fabricCanvasRef.current,
        aspectRatio
      );
      
      if (!croppedImageUrl) {
        throw new Error('Failed to generate cropped image URL');
      }
      
      console.log('Cropped image generated successfully', { 
        panelId, 
        hasUrl: !!croppedImageUrl,
        urlPreview: `${croppedImageUrl.substring(0, 50)}...` 
      });
      
      // Call onSave with the panelId and croppedImageUrl
      if (typeof onSave === 'function') {
        // Ensure panelId is passed correctly, even if it's 0
        // Note: In JavaScript, 0 is falsy, so we need to check explicitly
        if (panelId !== undefined && panelId !== null) {
          console.log(`Calling onSave with panelId: ${panelId}`);
          onSave(panelId, croppedImageUrl);
        } else {
          console.error('No panelId available for saving');
          onSave(null, croppedImageUrl);
        }
      } else {
        console.error('onSave is not a function');
      }
      
      onClose();
    } catch (err) {
      console.error('Error saving image:', err);
      safeSetError("Failed to save image. Please try again.");
    } finally {
      setIsSaving(false);
    }
  };
  
  return (
    <Dialog
      open={open}
      onClose={() => !isSaving && onClose()}
      maxWidth="md"
      fullWidth
      PaperProps={{
        sx: {
          height: '90vh',
          maxHeight: 700,
          display: 'flex',
          flexDirection: 'column'
        }
      }}
      TransitionProps={{
        onEntered: () => {
          // This ensures the canvas is initialized after the dialog is fully open
          console.log('Dialog fully opened, canvas ref:', !!canvasRef.current);
          if (canvasRef.current && !fabricCanvasRef.current) {
            console.log('Initializing canvas after dialog transition');
            try {
              fabricCanvasRef.current = initCanvas(canvasRef.current);
              setCanvasReady(true);
              forceUpdate();
            } catch (err) {
              console.error('Error initializing canvas after transition:', err);
            }
          }
        }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h6">Edit Image</Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <IconButton edge="end" color="inherit" onClick={onClose} disabled={isSaving}>
            <Close />
          </IconButton>
        </Box>
      </DialogTitle>
      
      <DialogContent sx={{ flex: 1, display: 'flex', flexDirection: 'column', p: 2 }}>
        <Box sx={{ 
          flex: 1, 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center',
          backgroundColor: '#f5f5f5',
          borderRadius: 1,
          position: 'relative',
          overflow: 'hidden'
        }}>
          {!imageLoaded && (
            <Box sx={{ 
              position: 'absolute', 
              display: 'flex', 
              flexDirection: 'column', 
              alignItems: 'center',
              gap: 2
            }}>
              <CircularProgress />
              <Typography variant="body2">Loading image...</Typography>
            </Box>
          )}
          
          {error && (
            <Box sx={{ 
              position: 'absolute', 
              display: 'flex', 
              flexDirection: 'column', 
              alignItems: 'center',
              gap: 2,
              color: 'error.main'
            }}>
              <Typography variant="body1" color="error">
                {error}
              </Typography>
              <Button 
                variant="outlined" 
                color="error" 
                onClick={() => onClose()}
                startIcon={<Close />}
              >
                Close Editor
              </Button>
            </Box>
          )}
          
          <canvas 
            ref={canvasRef} 
            style={{ 
              maxWidth: '100%', 
              maxHeight: '100%',
              visibility: imageLoaded ? 'visible' : 'hidden' 
            }} 
          />
        </Box>
        
        <Box sx={{ mt: 2, p: 2, borderTop: '1px solid #eee' }}>
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Typography variant="body2" sx={{ mr: 2, minWidth: 70 }}>Zoom: {zoom}%</Typography>
            <Tooltip title="Zoom Out">
              <IconButton size="small" onClick={() => handleZoomChange(Math.max(50, zoom - 10))}>
                <ZoomOut />
              </IconButton>
            </Tooltip>
            
            <Slider
              value={zoom}
              min={50}
              max={200}
              step={5}
              onChange={(_, newValue) => handleZoomChange(newValue)}
              sx={{ mx: 1, flexGrow: 1 }}
              disabled={!imageLoaded || !!error}
            />
            
            <Tooltip title="Zoom In">
              <IconButton size="small" onClick={() => handleZoomChange(Math.min(200, zoom + 10))}>
                <ZoomIn />
              </IconButton>
            </Tooltip>
          </Box>
          
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Typography variant="body2" sx={{ mr: 2, minWidth: 70 }}>Rotation: {rotation}°</Typography>
              
              <Tooltip title="Rotate Left">
                <IconButton size="small" onClick={() => handleRotate(-90)} disabled={!imageLoaded || !!error}>
                  <RotateLeft />
                </IconButton>
              </Tooltip>
              
              <Tooltip title="Rotate Right">
                <IconButton size="small" onClick={() => handleRotate(90)} disabled={!imageLoaded || !!error}>
                  <RotateRight />
                </IconButton>
              </Tooltip>
            </Box>
            
            <Tooltip title="Reset Image">
              <IconButton color="primary" onClick={handleReset} disabled={!imageLoaded || !!error}>
                <Replay />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>
      </DialogContent>
      
      <DialogActions>
        <Button onClick={onClose} disabled={isSaving}>
          Cancel
        </Button>
        <Button 
          onClick={handleSave} 
          color="primary" 
          variant="contained" 
          disabled={!imageLoaded || isSaving || !!error}
          startIcon={isSaving ? <CircularProgress size={20} color="inherit" /> : <Save />}
        >
          {isSaving ? 'Saving...' : 'Save Changes'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default PanelImageEditor; 

===== FILE: /Users/davis/Projects/Vibe-House-LLC/memeSRC/src/components/collage/hooks/useCollageState.js =====

import { useState, useEffect } from 'react';
import { getLayoutsForPanelCount } from '../config/CollageConfig';

// Debug flag - only enable in development mode
const DEBUG_MODE = process.env.NODE_ENV === 'development';

/**
 * Custom hook to manage collage state
 */
export const useCollageState = () => {
  const [selectedImages, setSelectedImages] = useState([]);
  const [panelImageMapping, setPanelImageMapping] = useState({});
  const [selectedTemplate, setSelectedTemplate] = useState(null);
  const [selectedAspectRatio, setSelectedAspectRatio] = useState('portrait');
  const [panelCount, setPanelCount] = useState(2); // Default panel count of 2
  const [finalImage, setFinalImage] = useState(null);
  const [isCreatingCollage, setIsCreatingCollage] = useState(false);
  const [borderThickness, setBorderThickness] = useState('medium'); // Default border thickness
  
  // Get the saved custom color from localStorage if available, otherwise use white
  const [borderColor, setBorderColor] = useState(() => {
    const savedCustomColor = localStorage.getItem('meme-src-collage-custom-color');
    return savedCustomColor || '#FFFFFF'; // Default white border color
  });

  // Save the custom color to localStorage when it changes
  useEffect(() => {
    localStorage.setItem('meme-src-collage-custom-color', borderColor);
  }, [borderColor]);

  // Initialize template on mount
  useEffect(() => {
    if (DEBUG_MODE) {
      console.log("useCollageState initializing...");
    }
    
    // Get compatible templates for initial panel count and aspect ratio
    const initialTemplates = getLayoutsForPanelCount(panelCount, selectedAspectRatio);
    
    if (DEBUG_MODE) {
      console.log("Initial templates:", {
        count: initialTemplates.length,
        panelCount,
        aspectRatio: selectedAspectRatio
      });
    }
    
    // Set the initial template if available
    if (initialTemplates.length > 0) {
      if (DEBUG_MODE) {
        console.log("Setting initial template:", initialTemplates[0].id);
      }
      setSelectedTemplate(initialTemplates[0]);
    } else {
      console.warn("No initial templates found!");
    }
  }, []); // Empty dependency array ensures this runs only once on mount

  // Select the most suitable template when panel count or aspect ratio changes
  useEffect(() => {
    const compatibleTemplates = getLayoutsForPanelCount(panelCount, selectedAspectRatio);
    
    // If no template is selected or the current one isn't compatible, select the first one
    if (!selectedTemplate || 
        selectedTemplate.minImages > panelCount || 
        selectedTemplate.maxImages < panelCount) {
      
      if (compatibleTemplates.length > 0) {
        // Select the first (highest priority) compatible template
        setSelectedTemplate(compatibleTemplates[0]);
      } else {
        setSelectedTemplate(null);
      }
    }
  }, [panelCount, selectedAspectRatio, selectedTemplate]);

  // Clean up ObjectURLs when component unmounts or when images are replaced
  useEffect(() => {
    return () => {
      selectedImages.forEach(url => {
        if (url && typeof url === 'string' && url.startsWith('blob:')) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [selectedImages]);

  /**
   * Add a new image to the collection
   * @param {string|Object} image - The image URL or object to add
   */
  const addImage = (image) => {
    setSelectedImages([...selectedImages, image]);
  };

  /**
   * Remove an image by index
   * @param {number} index - The index of the image to remove
   */
  const removeImage = (index) => {
    // Create a copy of the images array without the removed image
    const newImages = [...selectedImages];
    const removedImage = newImages.splice(index, 1)[0];
    
    // Clean up the object URL if it's a blob URL
    if (removedImage && typeof removedImage === 'string' && removedImage.startsWith('blob:')) {
      URL.revokeObjectURL(removedImage);
    }
    
    setSelectedImages(newImages);
    
    // Also update panel mapping to remove references to this image
    const newMapping = {};
    Object.entries(panelImageMapping).forEach(([panelId, mappedIndex]) => {
      if (mappedIndex === index) {
        // This panel was pointing to the removed image, so remove the mapping
        // (do nothing, which will remove it from newMapping)
      } else if (mappedIndex > index) {
        // This panel was pointing to an image after the removed one, so adjust the index
        newMapping[panelId] = mappedIndex - 1;
      } else {
        // This panel points to an image before the removed one, so keep it the same
        newMapping[panelId] = mappedIndex;
      }
    });
    
    setPanelImageMapping(newMapping);
  };

  /**
   * Update an image at a specific index
   * @param {number} index - The index of the image to update
   * @param {string|Object} newImage - The new image URL or object
   */
  const updateImage = (index, newImage) => {
    if (index >= 0 && index < selectedImages.length) {
      const oldImage = selectedImages[index];
      // Clean up the old image URL if it's a blob
      if (oldImage && typeof oldImage === 'string' && oldImage.startsWith('blob:')) {
        URL.revokeObjectURL(oldImage);
      }
      
      // Create a new array with the updated image
      const newImages = [...selectedImages];
      newImages[index] = newImage;
      setSelectedImages(newImages);
    }
  };

  /**
   * Clear all selected images
   */
  const clearImages = () => {
    // Clean up all blob URLs
    selectedImages.forEach(image => {
      if (image && typeof image === 'string' && image.startsWith('blob:')) {
        URL.revokeObjectURL(image);
      }
    });
    
    setSelectedImages([]);
    setPanelImageMapping({});
  };

  /**
   * Update the mapping between panels and images
   * @param {Object} newMapping - The new panel-to-image mapping
   */
  const updatePanelImageMapping = (newMapping) => {
    if (DEBUG_MODE) {
      console.log("Updating panel image mapping:", {
        previous: Object.keys(panelImageMapping),
        new: Object.keys(newMapping),
        changes: Object.keys(newMapping).filter(key => 
          panelImageMapping[key] !== newMapping[key]
        )
      });
    }
    
    setPanelImageMapping(newMapping);
  };

  return {
    // State
    selectedImages,
    panelImageMapping,
    selectedTemplate,
    setSelectedTemplate,
    selectedAspectRatio,
    setSelectedAspectRatio,
    panelCount,
    setPanelCount,
    finalImage,
    setFinalImage,
    isCreatingCollage,
    setIsCreatingCollage,
    borderThickness,
    setBorderThickness,
    borderColor,
    setBorderColor,
    
    // Operations
    addImage,
    removeImage,
    updateImage,
    clearImages,
    updatePanelImageMapping,
  };
}; 